\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage[font={scriptsize}]{caption}
\usepackage{hyperref}
\usepackage{afterpage} %for adding a black page
\usepackage{placeins}
\usepackage{float}
\usepackage{array}
\usepackage{enumitem}
\usepackage{enumerate}
\usepackage{wrapfig}

% opening
\title{\Huge{UVM-Simulationsmodell eines JTAG-Interfaces}}
\date{\today}
\author{Serin Varghese}

\newcommand\blankpage{%
\null
\thispagestyle{empty}%
\addtocounter{page}{-1}%
\newpage}

\afterpage{\blankpage}

\geometry{
  body={7in, 8.5in},
  left=1.0in,
  right=0.75in,
  top=1in
}

\hypersetup
{
    colorlinks=false,
    pdfborder={0 0 0},
}

\begin{document}

\maketitle
\pagebreak

\newlength{\toptafiddle} 
\newlength{\bottafiddle}
\setlength{\toptafiddle}{1in}
\setlength{\bottafiddle}{1in}
\vspace*{-0.5in}
\enlargethispage{\bottafiddle}
\thispagestyle{empty}

\graphicspath{{./images/}}

\begin{center}
\ UVM-Simulationsmodell eines JTAG-Interfaces \\
\vspace{0.2cm}

\begin{figure}[!h]
\centering
\includegraphics[height=4cm]{TU_Chemnitz_logo}
\end{figure}

Masters in Micro and Nano Systems\\
Fakultät für Elektrotechnik und Informationstechnik\\
Professur Schaltkreis- und Systementwurf\\
Technische Universität Chemnitz\\
\end{center}

This is to certify that the work entitled \textgravedbl UVM-Simulationsmodell eines JTAG-Interfaces \textacutedbl is a bonafide work carried out by 
(\textbf{Varghese, Serin John; \textit{Immatrikulation Nr. 328799}})
is a contribution to Schaltkreis- und Systementwurf, Masters in Micro and Nano
Systems, Technische Universität Chemnitz.

\vfill
\begin{minipage}[t]{0.5\textwidth}%
\emph{Betreuer/Prüfer}\\
Dipl.-Ing. Marcel Putsche\\
SSE Department,\\
TU Chemnitz
\end{minipage}\hspace{0.5cm}
\begin{minipage}[t]{0.5\textwidth}%
\emph{Betreuer/Prüfer}\\
Dipl.-Ing. Thomas Horn\\
SSE Department,\\
TU Chemnitz, \\


\end{minipage}\vfill
\vfill


\vfill
\begin{minipage}[t]{0.3\textwidth}%
\begin{tabular}{lcc}
 &  & \tabularnewline
 &  & \tabularnewline
 &  & \tabularnewline
Date & : & \tabularnewline
Place &: & Chemnitz\tabularnewline
\end{tabular}%

\end{minipage}

%===============================================================================================================
\pagebreak
\section*{\LARGE{Acknowledgement}}

%
%

\newpage

\begin{abstract}

%
\footnote{Keywords: Universal Verification Methodology, JTAG, verification component, TAP controller, boundary scan}
\end{abstract}

%===============================================================================================================
\newpage
\tableofcontents

%===============================================================================================================
\newpage
\section{Abbreviations used}
\begin{itemize}[noitemsep]
 \item UVM  - Universal Verification Methodology 
 \item OVM  - Open Verification Methodology
 \item DUT  - Device Under Test
 \item BSDL - Boundary Scan Description Language
 \item DR   - Data Register
 \item IR   - Instruction Register
 \item TAP  - Test Access Port
 \item TCK  - Test ClocK input
 \item TDI  - Test Data Input
 \item TDO  - Test Data Output
 \item TMS  - Test Mode Select
 \item TRST - Test ReSeT input
 \item VC   - Verification Component
 \item IP   - Intellectual Property 
 \item PCB  - Printed Circuit Board
 \item IC   - Integrated Circuit
 \item FSM  - Finite State Machine
 \item BSR  - Boundary Scan Register
 \item RTL  - Register Transfer Level
 \item DUT  - Device Under Test
 \item IDE  - Integrated Development Environment
\end{itemize}


%===============================================================================================================
\newpage
\pagebreak
\section{Introduction}

\subsection{Introduction to Boundary Scan and JTAG}
Boundary Scan is a method of testing interconnects on PCBs and internal IC sub-blocks. This standard is defined in IEEE 1149.1
For boundary scan tests, additional logic is added to the device. The boundary scan cells are placed between the core logic and the ports.

JTAG is an established technology(and industry standard) with a potential that is only now becoming fully realised. Connection testing and In System Programming(ISP) are the two applications most often associated with JTAG, but it has far more to offer.
\subsubsection{Background}
JTAG was initially conceived to address difficulties in testing circuits using the traditional 'bed-of-nails' approach. Modern packaging technologies like BGA and Chip Scale Packaging limit and in some cases eliminate physical access to pins.
JTAG overcomes this problem, by placing cells between the external connections and the internal logic of the device. With the cells configured as a shift register, JTAG can be used to set and retrieve the values of pins(and nets connected to them) without physical access.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=6cm,height=6cm]{images/introJtagLayout}
\caption{JTAG Block Diagram}
\end{figure}

There is also an option to sample the data values as they pass between the core logic and the pins during the normal operation of the device.

The JTAG interface adds four extra pins to each device:
\begin{itemize}[noitemsep]
\item TDI to input data to the device
\item TDO to output data from the device
\item TMS to control what should be done with the data
\item TCK clock signal to synchronize everything
\end{itemize}

If a circuit contains more than one JTAG-compliant device, these can be linked together to form a JTAG chain. In a JTAG chain the data output from the first device becomes the data input to the second device; the control and the clock signals are common to all the devices in the chain. Fig. provides a representation of a simple JTAG chain containing three devices.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{introJtagBlock}
\caption{Simple JTAG Device1}
\end{figure}

\subsubsection{Test Access Port (TAP)}
Each test logic function is accessed through the TAP. The five pins associated with the TAP are listed on the \ref{table:tap} with their corresponding descriptions. Four pins - TMS, TCK, TDI, and TDO - are always required for JTAG operation. The fifth pin, TRST, is optional. These pins are dedicated pins - used only with the test logic. 

\begin{center}
\begin{table}[!h]
\caption{Test Access Port Descriptions}
\label{table:tap}
\begin{tabular}{|c|c|}
 \hline
 \textbf{Port} & \textbf{Description} \\ \hline
 Test Mode Select (TMS) & \multicolumn{1}{m{11cm}|}{Serial Input  for the test logic control bits. Data is captured on the rising edge of the test logic clock (TCK). An internal pull-up resistor is present in dedicated mode but not in flexible mode. }\\\hline
 Test Clock Input (TCK) & \multicolumn{1}{m{11cm}|}{Dedicated test logic clock used serially to shift test instruction, test data, and control inputs on the rising edge of the clock, and serially to shift the output data on the falling edge of the the clock.}\\\hline
Test Data Input (TDI) & \multicolumn{1}{m{11cm}|}{Serial input for instruction and test data. Data is captured on the rising edge of the test logic clock. This pin is equipped with an internal pull-up resistor.}\\\hline
Test Data Output (TDO) & \multicolumn{1}{m{11cm}|}{Serial output for test instruction and data from the test logic. TDO is set to an Inactive Drive state (high impedance) when data scanning is not in progress.}\\\hline
Test Reset (TRST) & \multicolumn{1}{m{11cm}|}{Active-low input which asynchronously resets the test logic. This pin is equipped with an internal pull-up resistor.}\\\hline
\end{tabular}
\end{table}
\end{center}

\FloatBarrier
TRST overrides the behavior of the TMS and TCK. In other words, asserting TRST resets the TAP controller regardless of the the states of the TMS and TCK. Also, if TAP controller is held in the reset state, the state machine remains in the 'Test Logic Reset' condition.

\subsubsection{TAP Controller}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{jtag_tap}
\label{fig:jtag_tap}
\caption{TAP CONTROLLER}
\end{figure}

The 16 states of the TAP controller finite state machine are shown in the fig \ref{}. The 1s and 0s shown adjacent to the state transitions represent the TMS values that must be present at the time of a rising edge at TCK for a state transition to occur. In the states that include the letters -IR, the instruction register operates. In the states that include the letters -DR, the test data registers operates (bypass, boundary scan).

By default, upon power up(or when TRST is asserted) the TAP controller enters the Test-Logic-Reset state. The TAP controller also has an inherent property for automatically reaching this state when the TMS signal is held high for atleast 5 clock signals.

The operation of each state is explained below:
\begin{itemize}[noitemsep]
\item \textbf{Test-Logic-Reset} \\All test logic is disabled in this controller state enabling the normal operation of the IC.
\item \textbf{Run-Test-Idle} \\In this controller state, the test logic in the IC is active only if certain instructions are present. For example, if an instruction activates the self test, then it is executed when the controller enters this state. The test logic in the IC is idle otherwise.
\item \textbf{Select-DR-Scan} \\This controller state controls whether to enter the Data Path or the Select-IR-Scan state.
\item \textbf{Select-IR-Scan} \\This controller state controls whether or not to enter the Instruction Path. The controller can return to the Test-Logic-Reset state otherwise.
\item \textbf{Capture-IR} \\In this controller state, the shift register bank in the Instruction register parallel loads a pattern of fixed values on the rising edge of TCK. The last two significant bits must always be '01'.
\item \textbf{Shift-IR} \\In this controller state, the instruction register gets connected between TDI and TDO, and the captured pattern gets shifted on each rising edge of TCK. The instruction available on the TDI pin is also shifted in on to the instruction register.
\item \textbf{Exit1-IR} \\This controller state controls whether to enter the Pause-IR state or Update-IR state.
\item \textbf{Pause-IR} \\This state allows the shifting of the instruction register to be temporarily halted.
\item \textbf{Exit2-IR} \\This controller state controls whether to enter either the Shift-IR state or Update-IR state.
\item \textbf{Update-IR} \\In this controller state, the instruction in the instruction register is latched to the latch bank of the Instruction Register on every falling edge of TCK. The instruction becomes the current instruction once it is latched.
\item \textbf{Capture-IR} \\In this controller state, the data is parallel-loaded into the data registers selected by the current instruction on the rising edge of TCK.
\item \textbf{Shift-DR, Exit1-DR, Pause-DR, Exit2-DR and Update-DR} \\These controller states are similar to the Shift-IR, Exit1-IR, Pause-IR, Exit2-IR and Update-IR states in the Instruction Path.
\end{itemize}

\subsubsection{Registers}
\begin{description}
\item [$\bullet$ Instruction Register]
The instruction register allows an instruction to be shifted into the design. The instruction is used to select the test to be performed or the test data register to be accessed or both. Optionally, the instruction register allows examination of design-specific information generated within the component.

Each IR cell in the Instruction Register has a shift-register stage and a latch stage for fault isolation of the board-level serial test data path.

%ADD IMAGE HERE
%\begin{figure}[ht]
%\centering
%\includegraphics[width=10cm,height=6cm]{instructionRegister}
%\caption{Instruction Register}
%\end{figure}

\begin{center}
\begin{table}[!h]
\caption{Supported Instructions}
\label{table:IR}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{Instruction} & \multicolumn{1}{m{2cm}|}{\textbf{IR-Code (IR3-IR0)}} & \multicolumn{1}{m{2cm}|}{\textbf{Instruction Type}} & \textbf{Description} \\ \hline
 
 EXTEST & 0000 & Mandatory & \multicolumn{1}{m{7cm}|}{Allows testing of off-line circuitry and board-level interconnections}\\\hline
 
 SAMPLE/PRELOAD & 0001 & Mandatory & \multicolumn{1}{m{7cm}|}{Allows a snapshot of the normal operation of the component to be taken and examined}\\\hline

 IDCODE & 0010 & Optional & \multicolumn{1}{m{7cm}|}{32-bit hard-wired Manufacturer ID, part number, and version number}\\\hline

BYPASS & 1111 & Mandatory & \multicolumn{1}{m{7cm}|}{Provides minimum-length (1-bit) serial path between TDI and TDO pins of component when no test operation of that component is required}\\\hline

 INTEST & XXXX & Optional & \multicolumn{1}{m{7cm}|}{Allows testing of on-chip system logic while component is assembled on the board}\\\hline 

\end{tabular}
\end{table}
\end{center}

\FloatBarrier
\item [$\bullet$ Data Register]
\  \\

\begin{enumerate}[I]%for capital Roman numbers
\item Boundary-Scan Register
\ \\
The boundary-scan register allows testing of circuitry external to a component, for example, board interconnect or external components that do not conform to this standard. The register also permits the system signals flowing into and out of the system logic to be sampled and examined without causing interference with the normal (nontest) operation of the on-chip system logic. Optionally, additional test functions may be supported - for example, testing of the on-chip system logic.

\item Bypass Register
\ \\
This provides a single-bit serial connection through the circuit when none of the other test data registers is selected. This register can, for example, be used to allow test data to flow through a particular device to other components in a product without affecting the normal operation of the particular component. 

\item Device Identification Register
\ \\
This is an optional test data register that allows the manufacturer, part number, and variant of a component to be determined.

\end{enumerate} 

\end{description}


\newpage
\pagebreak
\subsection{Introduction to Verification Methodologies:}


\subsubsection{Classical verification vs Constraint based verification:}

With the increasing complexity of the digital systems, comes the need to have smarter ways to verify the functionality of the designed DUT. Initially the digital were tested with tediously written test-benches and then observing the respective waveform. The higher complexity did no longer allow for the manual checks and there was a need to automate the verification methods.

Verification planning and management involves identifying the features of the DUT that need to be verified, prioritizing those features, measuring progress, and adjusting the allocation of verification resources so that verification closure can be reached on the required timescale. The mechanics of verification can be accomplished using static formal verification in the context of UVM focuses on the simulation-based verification environment.

There are two contrasting approaches to coverage-driven verification in current use. "Classical" constrained random verification starts with random stimulus and gradually tightens the constraints until coverage goals are met, relying on brute power of randomization and compute server farms to cover the state farms to cover the state space. More recently, graph-based stimulus generation (also known as Intelligent Testbench) starts from an abstract description of the legal transitions between the high-level states of the DUT, and automatically enumerates the minimum set of tests needed to cover the paths through this state space. For many application, graph-based stimulus is able to achieve high coverage in far fewer cycles than "classical" constrained random. UVM directly supports constrained random, whereas graph-based stimulus generation requires a separate, dedicated tool. Stimulus generated from the graph-based approach can be executed on a UVM verification environment.

Functional coverage and code coverage measure different things. Code coverage measures the execution of the actual RTL code (which must therefore exist before the code coverage can run at all). The collection of code coverage information, including statement and branch coverage, state coverage, and state transition coverage, is largely automatic. Functional coverage, on the other hand, attempts to measure whether the features described in the verification plan have actually been executed by the DUT. The feature to be measured have to be decided from the specification and implementation of the design to create the verification plan, and so functional coverage can be considered as a qualitative measure of DUT code execution. 

The best practice is to create a verification plan that consists of a list of features to be tested as opposed to a list of direct test descriptions. All stakeholders in the verification process should contribute to the identification and prioritization of features in the verification plan, since this feature set will form the foundation for the subsequent verification process.

\subsubsection{Advantages of Functional coverage}
Functional coverage helps to identify

\begin{itemize}[noitemsep]
\item the features in the verification plan that have been successfully tested
\item the features in the verification plan that have yet to be tested
\item the proportion of the features that have been tested and thus how close the verification process is to completion
\item the set of tests that provide maximum coverage using the minimum number of CPU cycles
\end{itemize}

In contrast, in traditional directed testing methodology, the absence of further bugs being detected is taken as evidence that verification is nearly complete. This may overcome some scenarios in which the DUT might fail.

\subsubsection{What is UVM?}
\ \\ 
\textbf{Introduction to UVM}
\ \\
UVM is a methodology for functional verification using SystemVerilog, complete with a supporting library of SystemVerilog code. UVM stands for Universal Verification Methodology. It was created by Accelera based on the OVM(Open Verification Methodology) version 2.1.1.

It is basically a methodology for the functional verification of digital hardware, primarily using simulation. The hardware or system would be typically be described using Verilog, SystemVerilog, VHDL or SystemC at any appropriate abstraction level. This could be behavioral, Register-transfer level, or gate level. UVM is explicitly simulation-oriented, but UVM can also be used alongside assertion-based verification, hardware acceleration or emulation.
\ \\
\ \\
\textbf{History}
\ \\
In December 2009, a technical subcommittee of Accellera - a standards organization in the electronic design automation (EDA) industry - voted to establish the UVM and decided to base this new standard on OVM 2.1.1, a verification methodology developed jointly in 2007 by Cadence Design Systems and Mentor Graphics.
In February 21, 2011, Accelera approved the 1.0 version of UVM. It included a Reference Guide, a Reference Implementation in the form of SystemVerilof base class library, and a User Guide.
\ \\
\ \\
\textbf{Checkers, Coverage and Constraints}
\ \\
Constrained random verificaiton relies on Checkers, Coverage and Constraints and these are supported by explicit features of the SystemVerilog language.

Firstly, checkers ensure functional correctness. Nothing is gained by throwing more and more random stimulus into a design to take functional coverage to ever higher levels unless the design-under test is being checked automatically for functional correctness. Checkers can be implemented by SystemVerilog assertions or using regular procedural code. UVM provides mechanisms and guidelines for building checkers into the verification environment and for logging reports.

Secondly, coverage provides a measure of the functional completeness of the testing, and tells us when we have met the goals set out in the verification plan, and thus when you have finished simulating. SystemVerilog offers two separate mechanisms for functional coverage collection; property-based coverage (cover directives) and sample-based coverage (covergroups). Both can be used in a UVM verification environment. The specification and the execution of the coverage information is intimately tied to the verification plan, and many simulation tools are able to annotate coverage information onto the verification plan document, facilitating tight management control.

Thirdly, constraints provide the means to reach coverage goals by shaping the random stimulus to push the DUT into interesting corner cases. Without shaping, random stimulus alone may be insufficient to exercise many of the deeper states of the DUT. Constrained random stimulus is still random, but the statistical distribution of the vectors is shaped to ensure that interesting cases are reached. Systemverilog has dedicated language features for expressing constraints, and UVM goes further by providing mechanisms that allow constraints to be written as a part of a test rather than embedded within verification components. this and other features of UVM facilitate the creating of reusable verification components.
\ \\
\ \\
\textbf{Verification Reuse}
\ \\
UVM facilitates the constructino of verification environments and tests, both by providing reusable machinery in the form of a library of SystemVerilog classes, and alos by providing a set of guidelines for best practice when using SystemVerilog for verification.

Verification productivity can be enhanced by reusing verification components, and this is an an important objective of UVM. Verification reuse is enabled by having a modular verification environment where each component has clearly defined responsibilities, by allowing flexibility in the wat in which components are configured and used, by having a mechanism to allow imported components to be customized to the application at hand, and by having well-defined coding guidelines to ensure consistency.

The architecture of UVM has been designed to encourage modular and layered verification environments, where verification components at all layers can be reused in different environments. Low-level driver and monitor components can be reused across multiple DUT. The whole verification environment can be reused by multiple tests and configured top-down by those tests. Finally, test scenarios can be reused from application to application. This degree of reuse is enabled by having UVM verification components able to be configured in a very flexible way without modification to their source code. This flexibility is built into the UVM class library.

%===============================================================================================================
\newpage
\pagebreak
\section{Objective and Specifications}

Development of a Universal Verification Methodology environment of the JTAG interface. It will contain the following functionality:

\begin{itemize}
\item Existing and verified IP core of a JTAG interface
\item Execution of the following Instructions: \\EXTEST, INTEST, SAMPLE/PRELOAD, BYPASS, IDCODE according to IEEE1149.1 standard
\item Enhanced test bench(es) to fully test the DUT
\end{itemize}

The simulation runs as well as the occurring challenges are documented.
\\ \textbf{IDE used:} Questa\textregistered Advanced Simulator, Mentor Graphics

%===============================================================================================================
\newpage
\pagebreak
\section{Developed Modules:}

\textbf{Blocks in UVM}
\ \\
We have a DUT and to test the functionality we have to simulate it. To achieve this, we will need a block that generates sequences of bits to be transmitted to the DUT. This block in UVM is called the \textit{Sequencer}. 

Usually the sequencer is unaware of the communication bus and the physical connections to the DUT. The sequencer is responsible only for generating generic sequences of data and then it is sent to another block that has direct access to the physical pins of the DUT. This block that interacts directly with the DUT is called the \textit{Driver}.

While the driver maintains activity with the DUT by feeding it data generated from the sequencers, it does not validate the applied stimuli. We need a block that will listen to the communication between the driver and the DUT. This block is called the \textit{Monitor}. Monitors sample the inputs/outputs of the DUT.

The monitor tries to make a prediction of the expected result and send the prediction and result of the DUT to another block of UVM. This block, the \textit{Scoreboard}, compares and evaluates these data from the monitor.

All these blocks together constitute a typical system used for verification and the same structure is used in UVM testbenches. This is represented in fig.\ref{fig}

Usually the sequence, the sequencer, the driver and the monitor compose an \textit{Agent}. An agent together with the scoreboard constitute an \textit{Environment}. All these blocks are controlled by a greater block denominated by \textit{Test}. The test block controls all the blocks and sub blocks of the testbench. By changing just a few lines of code, we could add, remove and override blocks in our testbench and build different environments without rewriting the whole test.
\ \\
\ \\
\textbf{UVM classes}
\ \\

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{introClassTree}
\caption{UVM Class Tree}
\end{figure}

The re-usability is one of the great advantages of UVM. This is mainly due to the concept of classes and objects from SystemVerilog.

In UVM, all the above mentioned blocks are represented as objects that are derived from the already existing classes.

A class tree of the most important UVM classes can be seen in the fig.\ref{fig}.

The data that travels to and from the DUT is stored in \textit{uvm\textunderscore sequence\textunderscore item} and \textit{uvm\textunderscore sequence}. The sequencer is derived from the \textit{uvm\textunderscore sequencer}, the driver is derived from the \textit{uvm\textunderscore driver} and so on.
\ \\
\ \\
\textbf{UVM Phases}
\ \\

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=2cm,height=4cm]{uvmPhases}
\caption{Instruction Register}
\end{figure}

All the above mentioned classes have simulation phases. Phases are ordered steps of execution implemented as methods. When we derive a new class, the simulation of our testbench goes through these different steps in order to construct, configure and connect the testbench.

\begin{itemize}

\item Build Phase:
\ \\
The build phase is used to construct components of the hierarchy. For example, the build phase of the agent class will construct the classes for the monitor, for the sequencer and for the driver.

\item Connect Phase:
\ \\
The connect is used to connect the different sub components of a class. Using the same example, the connect phase of the agent connects the driver to the sequencer and the monitor is connected to an external port.

\item Run Phase:
\ \\
The run phase is the main phase of the execution. This is where the actual code of a simulation will execute.

\item Report Phase:
\ \\
Finally, the report phase is the phase where the results of the simulation are displayed.

\end{itemize}
\ \\
\ \\
\textbf{UVM Macros}
\ \\
Macros are an important aspect of UVM. These macros implement some useful methods in classes and in variables. Though they are optional to use, using them simplifies the process of code development and testing.

The most common ones are:
\begin{itemize}

\item `uvm\textunderscore component\textunderscore utils
\ \\
This macro registers the new class type. It is used when deriving new classes like a new agent, driver, monitor and so on.

\item `uvm\textunderscore fie`ld\textunderscore init
\ \\
This macro registers a variable in the UVM factory and implements some functions like copy(), compare() and print().

\item `uvm\textunderscore info
\ \\
This is a very useful macro which we have used to print messages from the UVM environment during simulation time.


\end{itemize}


\subsection{Device Under Test with JTAG capability}
The designed DUT is JTAG compliant. The objective of our project is to develop a UVM Test for a JTAG interface. We would design a basic full adder with JTAG capabilities. The full adder module can be replaced with any other DUTs and the same testbench would implement the same JTAG tests accurately.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=10cm]{AdvancedDut}
\caption{Developed Design Under Test}
\end{figure}

\FloatBarrier
\subsubsection{Boundary Scan Cells Modules}
\underline{\textbf{Located in:} \textit{InputCell.v} and \textit{OutputCell.v}}\\

The boundary-scan test architecture provides a means to test interconnects between integrated circuits on a board without using physical test probes. It adds a boundary-scan cell that includes a multiplexer and latches to each pin on the device. Boundary-scan cells in a device can capture data from pin or core logic signals, or force data onto pins. Captured data is serially shifted out and externally compared to the expected results. Forced test data is serially shifted into the boundary-scan cells. All of this is controlled from a serial data path called the scan path or scan chain. Figure 1 depicts the main elements of a boundary-scan cell. By allowing direct access to nets, boundary-scan eliminates the need for a large number of test vectors, which are normally needed to properly initialize sequential logic. Tens or hundreds of vectors may do the job that had previously required thousands of vectors. Potential benefits realized from the use of boundary-scan are shorter test times, higher test coverage, increased diagnostic capability and lower capital equipment cost.

Data is passed serially through the Boundary Scan Registers which help in debugging the state of the inputs and the outputs.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{BoundaryScanCell}
\caption{Boundary Scan Cell}
\end{figure}


\textbf{Output Boundary Scan Cell:}
This is the Boundary Scan Cell that is connected to the output side of the Full Adder Module. When the DUT is running in JTAG mode, then the TDI and TDO are connected between the boundary scan registers and this path is called the 'Scan Path'. The JTAG mode, the value in the instruction register decides the flow of information from the Scan Path. In normal operation mode, these boundary scan cells pass the Full Adder outputs to the outputs of the DUT.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=17cm,height=4cm]{OutputCellCode}
\caption{Output Cell Code}
\end{figure}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=7cm,height=4cm]{OutputDUT}
\caption{Output DUT}
\end{figure}

\FloatBarrier
\textbf{Input Boundary Scan Cell:}
This is the Boundary Scan Cell that is connected to the output side of the Full Adder Module. In normal operation mode, these boundary scan cells pass the input given to the DUT to the Full Adder input ports. The JTAG mode, the value in the instruction register decides the flow of information from the Scan Path.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=17cm,height=3cm]{InputCellCode}
\caption{Input Cell Code}
\end{figure}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=7cm,height=4cm]{InputDUT}
\caption{Input Cell Code}
\end{figure}

In addition to the parallel in, parallel out, serial in and serial out lines, the captureDR, ShiftDR, UpdateDR and TCK pins are also passed to this module from the TAP controller module. These signals indicate the Boundary Scan of the mode in which the DUT is operating in.

InputCell.v and OutputCell.v are the files that contain the input boundary scan cell and output boundary scan cell respectively.


\FloatBarrier
\subsubsection{TAP Controller Module}
\underline{\textbf{Located in:} \textit{tap\_top.v}}\\

The TAP controller module controls all the operation of the DUT when in the JTAG test operation mode. The TCK, TDI, TRST and TMS are the inputs to this module. The TDO pin is the output from this module. The TAP controller also contains the instruction register, the BYPASS register and the IDCODE register.

When the instruction register contains the instruction for IDCODE operation, the TDI and TDO are connected between the IDCODE registers. On every falling edge of the TCK signal, the IDCODE register is shifted out bit by bit to the TDO pin.

The BYPASS register is a one bit register that is connected between the TDI and TDO pin when the BYPASS instruction is selected. So the TDO follows the TDI with one clock cycle delay.

The operation of the TAP controller is controlled by the TMS pin. Fig. \ref{fig:jtag_tap} shows how the TAP controller states change. The Finite-State Machine for the TAP controller has been implemented and tested.


\FloatBarrier
\subsubsection{Full Adder Module}
\underline{\textbf{Located in:} \textit{full\_adder.v}}\\

The full adder module implements the basic operations of the Full adder. It has three inputs and Sum and Carry outputs. This module is written in the full\_ addder.v file.\\

\underline{Ports of the full adder:}
\begin{itemize}[noitemsep]
\item A - input
\item B - input
\item Cin - input
\item Sum - output
\item Cout - output
\end{itemize}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=11cm,height=5cm]{fullAdderCode}
\caption{Full Adder Module Code}
\end{figure}

%===============================================================================================================
\FloatBarrier
\subsection{UVM Modules}
This contains all the modules that are required for the verification environment
%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{phase3Environment}
\caption{Designed Verification Environment}
\end{figure}

Each of these blocks are explained in detail below. It also contains actual snapshots of the code for easier understanding.

\FloatBarrier
\subsubsection{Top Block}
\underline{\textbf{Located in:} \textit{testbench.sv}}\\

Generally the development of the DUT is done independently of the development of the testbench environment. The testbench top module connects the DUT to the verification components. A virtual interface is defined and added to the database so that all the modules that have access to the DUT can invoke it from the database.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=11cm,height=9cm]{topTestCode}
\caption{Testbench Top Code}
\end{figure}

The Top contains the following:

\begin{itemize}[noitemsep]
\item DUT Instance
\item Interface instance
\item Clock Generator block
\item start the test
\item set config\_db
\item waveform dump logic
\end{itemize}
 

%\FloatBarrier
\subsubsection{Test Block}
\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The test file is derived from the uvm\_test class. The test defines the test scenario for the testbench. It contains the environment, configuration properties, class overrides etc. A sequence can also be connected from this block. This test block runs when the run\_test() function is called. Here, the test also defines the environment.
%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=11cm,height=9cm]{testCode}
\caption{Test Code}
\end{figure}


\FloatBarrier
\subsubsection{Environment Block}
\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The environment is derived from the uvm\_env class. The environment defines the Agent and the Scoreboard in the build phase. In the connect phase, the outputs from the monitor are connected to the scoreboard.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=11cm,height=9cm]{environmentCode}
\caption{Environment Code}
\end{figure}

\FloatBarrier
\subsubsection{Agent Block}

\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The build phase of the driver executes the following commands:
\begin{itemize}[noitemsep]
\item Instantiate the ports that are used to connect to the monitor
\item Instantiate the sequencer block
\item Instantiate the agent block
\item Instantiate the monitor block for reading TDI 
\item Instantiate the monitor block for reading TDO
\end{itemize}

The connect phase of the driver executes the following commands:
\begin{itemize}[noitemsep]
\item The seq\_item\_port of the driver is connected to the seq\_item\_export of the sequencer
\item The uvm\_analysis\_port of TDI monitor is connected to the uvm\_analysis\_port of the agent
\item The uvm\_analysis\_port of TDO monitor is connected to the uvm\_analysis\_port of the agent
\end{itemize}

The agent also contains the following blocks:
\begin{itemize}[noitemsep]
\item Sequence or Transaction Block
\item Sequencer Block
\item Driver Block
\item Monitors Block
\end{itemize}
These blocks and their snapshots are explained more in detail further.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=9cm]{agentCode}
\caption{Agent code}
\end{figure}


\FloatBarrier
\paragraph{Sequence or Transaction Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The first step in testing our RTL design is to decide what kind of transaction is to be passed to the Driver. The transaction is designed by extending the uvm\_ sequence\_ item class. This includes the information needed to model the communication between the UVM components.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=7cm]{transaction}
\caption{Transaction code}
\end{figure}

\FloatBarrier
\paragraph{Sequencer Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

After a basic transaction has been defined, the verification environment will need to generate a collection of them and get them ready to be sent to the driver. This is the job of the sequencer. Sequencer is extended from the uvm\_ sequence and its main job is to generate multiple transactions. Sequences are an ordered collection of transactions and they shape transactions to our needs and also generate as many as we need. We could also constrain the range of randomization to the valid range to reduce simulation time in invalid values. 
These transactions are then transferred to the driver module.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{sequencerCode}
\caption{Sequencer code}
\end{figure}

\FloatBarrier
\paragraph{Driver Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The role of the driver block is to directly interact with the DUT. The driver pulls transactions from the sequencer and sends them repetitively to the signal-level interface. This interaction will be observed and evaluated by another block, the monitor. The driver toggles the TMS and the TDI pins to traverse through the TAP controller. The values of the TDI are shifted into the IR or the DR register depending on the state of the TAP controller. The driver module is extended from the uvm\_ driver class.
The run phase of the driver does the following:

\begin{itemize}[noitemsep]
\item Gets a sequence item from sequencer
\item Drive the sequence item to the DUT
\item Wait for a possible few clock cycles for the DUT to respond
\item Tell the sequencer that the current process is complete
\item Ask the sequencer to send the next sequence item
\end{itemize}

The config\_db places the defined virtual interface in the database so that it can be accessed by the driver module. Using the similar process, the interface can be loaded into any block which accesses the DUT directly.\\

\underline{\textbf{UVM Driver Methods:}}\\
\textbf{get\_next\_item} \\This method blocks the driver till a sequence\_item is available at the sequencer\\
\textbf{item\_done} \\The non-blocking item\_done()method will return a null pointer if there is no sequence\_item available in the sequencer.
\\
 \\
\underline{\textbf{Tests implemented in the driver:}}\\
\textbf{Bypass Instruction} \\
The selection of the Bypass instruction is done by declaring \textit{`define BYPASS\_INSTR}.\\ \underline{Note:} Do not run two tests simultaneously. \\
The tests for the bypass instruction are added in the run phase of the driver. The comments in the code mention exactly what each step does. Variable data stream length can be defined. A global variable \textit{DATA\_LENGTH} is defined in the \textit{my\_sequence.svh} file. The value will correspond to the length of the data stream that is sent from the TDI to the TDO. \\
 \\
The values of the TDI and TDO are stored by the monitor and then written into the scoreboard. The function \textit{compareForBypass()} compares the TDI and TDO values and the result is printed in the console of the QuestaSim during simulation. \\
 \\
 To introduce error into the bypass instruction the variable \textit{introduceErrorBypass} should be set to 1. This introduces a stuck-at-1 error at TDO pin. The function \textit{compareForBypass()} compares the two data streams and gives out an error on the console as the TDO and the TDI values do not match.\\
 \\
\textbf{Idcode Instruction} \\
The selection of the Idcode instruction is done by declaring \textit{`define IDCODE\_INSTR}.\\
The tests for the IDCODE are also defined in the run phase of the driver. The comments in the code mention exactly what each step does. Here, variable data streams cannot be defined as the length of the IDCODE register is defined in the IEEE Standard 1149.1\\
 \\
The values of the TDI and TDO are stored by the monitor and then written into the scoreboard. The function \textit{compareForIdcode()} compares the TDO values with the values of the IDCODE defined in the DUT . The result is printed in the console of the QuestaSim during simulation. Incase of an error, the IDCODE that is read by the verification environment is also printed out on the console. \\
 \\
 To introduce error into the IDCODE instruction the variable \textit{introduceErrorIdcode} should be set to 1. This introduces an error in the value that is read from the IDCODE register. The function \textit{compareForIdcode()} compares the two data streams and gives out an error on the console as the TDO values and the IDCODE register values do not match.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=7cm]{driverCode}
\caption{Driver code}
\end{figure}


\FloatBarrier
\paragraph{Monitors Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\
The monitor is derived from the uvm\_monitor. Monitor is a passive block that observes the communication of the DUT with the verification environment. The monitor also returns an error if the response of the DUT does not match with the expected results. It is passive because it does not drive any signals to the DUT. The monitor samples the DUT signals through the virtual interface and converts the signal level activity to transaction level activity.

Monitor uses TLM ports to point to the DUT signals. There are two monitors that have been defined in out verification environment. One monitor is used to sample the inputs that are driven from the driver to the DUT( TDI ). The second monitor samples the response of the DUT (TDO) and converts in into transaction level activity. All these are written to the scoreboard.


%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=7cm]{monitorBeforeCode}
\caption{Monitor code for TDI}
\end{figure}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=7cm]{monitorAfterCode}
\caption{Monitor code for TDO}
\end{figure}

\FloatBarrier
\subsubsection{Scoreboard Block}
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The scoreboard module is extended from the uvm\_scoreboard class. uvm\_scoreboard is inherited by uvm\_component. The signals from the monitors are connected to the scoreboard.
%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=7cm]{scoreboardCode}
\caption{Scoreboard code}
\end{figure}




%===============================================================================================================
\FloatBarrier
\newpage
\pagebreak

\section{Testing and Problems faced}
\subsection{Phase I: Basic communication}
In this phase, the DUT that we use is a dummy DUT. Its only work is to print out the data as it receives it. The interface of the DUT is similar to that of an 8-bit memory block with data address and data registers. A transaction is defined and a sequence is passed to a sequencer. This sequence then calls on to the driver to access the DUT. The environment used to develop the code is EDAPlayground. EDAPlayground is an online simulator where there is no download required to run the code. For initial testing, this was easier to use as the samples codes are readily available.  
The work-flow is given below:

\begin{itemize}[noitemsep]
\item Classes for sequence, sequencer and driver are written
\item UVM builds, connects and runs these classes
\item A transaction is created
\item A randomized and constrained sequence (address and data) is sent to the DUT
\item Sequencer sends the sequence to the Driver and waits for item\textunderscore done signal from the driver
\item Driver toggles these data on to the DUT through the interface and then sends item\textunderscore done signal to the sequencer
\item UVM reporting is activated as long as the system does not receive a reset signal
\item Repeat sending sequences to the driver and observe the signals
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase1Environment}
\caption{Basic Communication Environment}
\end{figure}

\subsubsection{Testing Results for Phase I}

\begin{figure}[ht]
\centering
\includegraphics[width=16cm,height=2cm]{images/testing1}
\caption{Phase I testing}
\end{figure}

The system reset is held low and normal operations are let to run. Randomized data and address is sent. From the waveform in Fig.\ref{?}, we can see that these signals are toggling with the input. The input parameters are randomized using the default \textit{randomize()} command in SystemVerilog. The input to the DUT here is a 8-bit data bus and the constraint on the value of the input is from 0 to 255. 

\subsubsection{Testing Conclusion for Phase I}
With this we have established a one-directional communication with our DUT. Also, the UVM Phases(build, connect, run and report) were tested. Our further developments have been built upon this basic building blocks. Here, we have not yet connected a monitor and scoreboard block. This would be included in phase III.
\ \\
\FloatBarrier
\subsection{Phase II: Adding JTAG DUT}

Phase 2 development was built over the existing architecture in Phase 1. Here we have added 

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase2Environment}
\caption{Environment after JTAG DUT addition}
\end{figure}

\subsubsection{Testing Results for Phase II}
\ \\
\ \\
\subsubsection{Testing Conclusion for Phase II}
\ \\ 
\ \\


%problems faced
\FloatBarrier
\subsection{Phase III: Adding Monitor and Scoreboard}

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase3Environment}
\caption{Complete Environment with Monitors and Scoreboard}
\end{figure}

\subsubsection{Testing Results for Phase III}

\ \\
\ \\
\subsubsection{Testing Conclusion for Phase III}
\ \\ 
\ \\

%===============================================================================================================
\newpage
\pagebreak
\section{Results}
\subsection{Instruction: IDCODE}
\ \\
\ \\
\subsection{Instruction: BYPASS}
\ \\
\ \\
\begin{figure}[ht]
\centering
\includegraphics[width=17cm,height=7cm]{images/testing_BYPASS_collage}
\caption{Result of the BYPASS instruction testing}
\end{figure}

\FloatBarrier
\subsection{Instruction: EXTEST}
\ \\
\ \\

\subsection{Instruction: INTEST}
\ \\
\ \\

\subsection{Instruction: SAMPLE/HOLD}
\ \\
\ \\


%===============================================================================================================
\newpage
\pagebreak
\section{Conclusion}

We have now implemented a Device under test with JTAG capabilities. This can now be further extended to any DUT that is designed by replacing the \textit{full\_adder.v} file with any file that has the DUT to be tested. Only \textit{top\_module.v} needs to be modified for the instantiation of the modules. The UVM environment would remain the same and we could test the complete functionality of the JTAG instructions.

The tests have been carried out to see the responses of the DUT to the BYPASS and IDCODE instructions. The UVM environment compares the received and the expected values and gives an output on the console of the IDE. The user does not have to use the waveforms to manually verify the integrity of the signals. This reduces the time and effort that goes into testing of modules.

Provision has also been made to intentionally introduce errors into the testing modes. This gives us an idea of how the response would be when there is something wrong with the DUT. Also, this functionality helps cross verify our verification environment.
%
\newpage
\bibliographystyle{latex8}
\begin{thebibliography}{i}
\bibitem[1]{colin} {\em The Test Access Port and Boundary-Scan Architecture}, Colin M Maunder, et al., IEEE Computer Society Press, Los Alamitos

\bibitem[2]{1149} {\em IEEE Std 1149.1-1993}, IEEE Standard Test Access Port, and Boundary-Scan Architecture, IEEE, Inc., New York

\bibitem[3]{parker} {\em The Boundary-Scan Handbook}, Kenneth P. Parker, Kluwer Academic Publishers, Norwell

\bibitem[4]{xjtag} {\em High-Level Guide to JTAG},
\url{https://www.xjtag.com/about-jtag/jtag-high-level-guide/}

\bibitem[5]{microsemi} {\em IEEE Standard 1149.1},
\url{https://www.microsemi.com/document-portal/doc_view/130050-ac160-ieee-standard-1149-1-jtag-in-the-sx-rtsx-sx-a-ex-rt54sx-s-families-app-note}

\bibitem[6]{xilinx} {\em JTAG - General Description of the TAP Controller states},
\url{https://www.xilinx.com/support/answers/3203.html}

\bibitem[7]{IEEE} {\em IEEE Standard Test Access Port and Boundary Scan Architecture}, IEEE-SA Standards Board, 14 June 2001

\bibitem[8]{doulos} {\em Coverage driven Verification Methodology},
\url{https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/}

\bibitem[9]{doulos1} {\em UVM Verification Primer}, John Aynsley
\url{https://www.doulos.com/knowhow/sysverilog/uvm/tutorial_0/}

\bibitem[10]{accellera1} {\em Accellera's UVM User's Guide 1.1}

\bibitem[11]{accellera2} {\em Accellera's UVM 1.1 Class Reference}

\bibitem[12]{verificationAcademy} {\em Verification Academy's UVM Cookbook}

\bibitem[13]{spear} {\em SystemVerilog for Verification: A Guide to Learning the TestBench Language Features}, Chris Spear

\bibitem[14]{goss} {\em Comprehensive Functional Verification: The Complete Industry Cycle}, John Goss

\bibitem[15]{colorlesscube} {\em UVM guide for Beginners}
\url{https://www.colorlesscube.com/uvm-guide-for-beginners/}

\bibitem[16]{edaplayground} {\em EDA Playground}
\url{https://www.edaplayground.com}

\bibitem[16]{edaplayground} {\em corelis.com}
\url{http://www.corelis.com/education/Boundary-Scan_Tutorial.htm}

\end{thebibliography} 
%
%
% 
 
\end{document}