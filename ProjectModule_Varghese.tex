\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage[font={scriptsize}]{caption}
\usepackage{hyperref}
\usepackage{afterpage} %for adding a black page
\usepackage{placeins}
\usepackage{float}
\usepackage{array}
\usepackage{enumitem}
\usepackage{enumerate}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{trace}

\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\lstdefinestyle{verilog-style}
{
	language=Verilog,
	basicstyle=\small\ttfamily,
	keywordstyle=\color{vblue},
	identifierstyle=\color{black},
	commentstyle=\color{vgreen},
	breaklines=true,
	numbers=left,
	numberstyle=\tiny\color{black},
	numbersep=10pt,
	tabsize=8,
	moredelim=*[s][\colorIndex]{[}{]},
	literate=*{:}{:}1
}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{
	\edef\@temp{\the\lst@token}
	\ifx\@temp\@lbracket \color{black}
	\else\ifx\@temp\@rbracket \color{black}
	\else\ifx\@temp\@colon \color{black}
	\else \color{vorange}
	\fi\fi\fi
}
\makeatother
% opening

\title{\Huge{UVM-Simulationsmodell \\eines JTAG-Interfaces}}
\author{Serin J. Varghese}
\date{}

\newcommand\blankpage{%
\null
\thispagestyle{empty}%
\addtocounter{page}{-1}%
\newpage}

\afterpage{\blankpage}

\renewcommand*\footnoterule{}


\geometry{
  body={7in, 8.5in},
  left=1.0in,
  right=0.75in,
  top=1in
}

\hypersetup
{
    colorlinks=false,
    pdfborder={0 0 0},
}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagebreak

\newlength{\toptafiddle} 
\newlength{\bottafiddle}
\setlength{\toptafiddle}{1in}
\setlength{\bottafiddle}{1in}
\vspace*{-0.5in}
\enlargethispage{\bottafiddle}
\thispagestyle{empty}

\graphicspath{{./images/}}

\afterpage{\blankpage}


\begin{figure}[!h]
\centering
\includegraphics[height=6cm]{TU_Chemnitz_logo}
\end{figure}

\begin{center}
{\Large Fakultät für Elektrotechnik und \\Informationstechnik\\
\ \\
RESEARCH PROJECT REPORT}\\
\ \\

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
{\Large \textbf{UVM-Simulationsmodell \\eines JTAG-Interfaces} \\}
\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
\ \\
\ \\
\end{center}


\begin{minipage}[t]{0.5\textwidth}%
	\begin{flushleft}
		\large \textit{Author}: \\
		Serin J. VARGHESE\\
		Immatrikulation Nr. 428459
	\end{flushleft}
\end{minipage}
%
\begin{minipage}[t]{0.5\textwidth}%
	\begin{flushright}
		\large \textit{Supervising Professor}: \\
		Prof. Dr.-Ing. habil. Göran HERRMANN\\
		\vspace*{0.5cm}
		\large \textit{Supervisors}: \\
		Dipl.-Ing. Marcel PUTSCHE\\
		Dipl.-Ing. Thomas HORN
	\end{flushright}
\end{minipage}

\ \\
\ \\
\ \\
\begin{center}

Submitted to the Fakultät für Elektrotechnik und Informationstechnik\\
Professur Schaltkreis- und Systementwurf\\
in partial fulfillment of the requirements for the degree of\\
Master of Science in Micro and Nano Systems\\
\ \\
Chemnitz, Germany\\
October, 2017\\
\end{center}

%===============================================================================================================
\pagebreak
\section*{\LARGE{Acknowledgement}}

I would first like to thank my thesis supervisor, Dipl.-Ing. Marcel Putsche, whose office was always open whenever I ran into a trouble spot or had a question about my research or writing. He consistently allowed this paper to be my own work, but steered me in the right direction whenever he thought I needed it.\\
\ \\
I would also like to thank the experts who were involved in the validation survey for this research project: Prof. Dr.-Ing. habil. Göran Hermann and Dipl.-Ing. Thomas Horn. Without their passionate participation and input, the validation survey could not have been successfully conducted. I am thankful for them to have allowed me to have taken up this Research Project which I have found to be very rewarding.\\
\ \\
I am grateful to my brother and my parents, who have provided me through moral and emotional support in my life. I am grateful to my other family members and friends who have supported me along the way. A special thanks to Ms. Priyanka Kamthe, who had to bear my frustration and listen to long talks on how my project was progressing. I thank all of them for their unwavering belief and confidence in me.\\
\ \\

%
%
%===============================================================================================================
\newpage

\begin{abstract}
A verification component is designed for a device with a JTAG interface. We have selected a full adder module with JTAG capability as our device under test. The instructions of Idcode, Bypass, Sample/Preload, Extest and Intest are implemented. All the implemented instructions are IEEE 1149.1 standard compliant. This verification component is designed with the use of the Universal Verification Methodology. Using the modules of the UVM environment, we have given the DUT a set of constrained stimulus and observed the response. The designed VC has the capability to introduce errors to understand how the VC would react to runtime errors. The errors, if any, are printed out on the console. This VC gives us an advantage of reusability wherein this full adder module can be replaced by any other module and the tests can be repeated with little effort. In this project we have designed the advanced DUTs with JTAG capability and verification environment, tested the working of the JTAG instructions and finally compared the expected data with the one that is actually observed. \\
\end{abstract}
\footnote{Keywords: Universal Verification Methodology, JTAG, verification component, TAP controller, boundary scan}


%===============================================================================================================
\newpage
\tableofcontents

%===============================================================================================================
\newpage
\section{Abbreviations used}
\begin{itemize}[noitemsep]
 \item BSDL - Boundary Scan Description Language
 \item BSR  - Boundary Scan Register
 \item DR   - Data Register
 \item DUT  - Device Under Test
 \item FSM  - Finite State Machine
 \item IC   - Integrated Circuit 
 \item IDE  - Integrated Development Environment
 \item IP   - Intellectual Property
 \item IR   - Instruction Register
 \item OVM  - Open Verification Methodology
 \item PCB  - Printed Circuit Board
 \item RTL  - Register Transfer Level
 \item TAP  - Test Access Port
 \item TCK  - Test ClocK input
 \item TDI  - Test Data Input
 \item TDO  - Test Data Output
 \item TMS  - Test Mode Select
 \item TRST - Test ReSeT input
 \item UVM  - Universal Verification Methodology
 \item VC   - Verification Component 
\end{itemize}


%===============================================================================================================
\newpage
\pagebreak
\section{Introduction}

\subsection{Introduction to Boundary Scan and JTAG}
Boundary Scan is a method of testing interconnects on PCBs and internal IC sub-blocks. This standard is defined in IEEE 1149.1
For boundary scan tests, additional logic is added to the device. The boundary scan cells are placed between the core logic and the ports.

JTAG is an established technology(and industry standard) with a potential that is only now becoming fully realised. Connection testing and In System Programming(ISP) are the two applications most often associated with JTAG, but it has far more to offer.
\subsubsection{Background}
JTAG was initially conceived to address difficulties in testing circuits using the traditional 'bed-of-nails' approach. Modern packaging technologies like BGA and Chip Scale Packaging limit and in some cases eliminate physical access to pins.
JTAG overcomes this problem, by placing cells between the external connections and the internal logic of the device. With the cells configured as a shift register, JTAG can be used to set and retrieve the values of pins(and nets connected to them) without physical access.\cite{xjtag}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=6cm,height=6cm]{images/introJtagLayout}
\caption{JTAG Block Diagram \cite{xjtag2}}
\end{figure}

There is also an option to sample the data values as they pass between the core logic and the pins during the normal operation of the device.

The JTAG interface adds four extra pins to each device:
\begin{itemize}[noitemsep]
\item TDI to input data to the device
\item TDO to output data from the device
\item TMS to control what should be done with the data
\item TCK clock signal to synchronize everything
\end{itemize}

If a circuit contains more than one JTAG-compliant device, these can be linked together to form a JTAG chain. In a JTAG chain the data output from the first device becomes the data input to the second device; the control and the clock signals are common to all the devices in the chain. Fig. provides a representation of a simple JTAG chain containing three devices.\cite{xjtag}


\subsubsection{Test Access Port (TAP)}
Each test logic function is accessed through the TAP. The five pins associated with the TAP are listed in Table \ref{table:tap} with their corresponding descriptions. Four pins - TMS, TCK, TDI, and TDO - are always required for JTAG operation. The fifth pin, TRST, is optional. These pins are dedicated pins - used only with the test logic.\cite{microsemi}

\begin{center}
\begin{table}[!h]
\caption{Test Access Port Descriptions\cite{microsemi}}
\label{table:tap}
\begin{tabular}{|c|c|}
 \hline
 \textbf{Port} & \textbf{Description} \\ \hline
 Test Mode Select (TMS) & \multicolumn{1}{m{11cm}|}{Serial Input  for the test logic control bits. Data is captured on the rising edge of the test logic clock (TCK). An internal pull-up resistor is present in dedicated mode but not in flexible mode. }\\\hline
 Test Clock Input (TCK) & \multicolumn{1}{m{11cm}|}{Dedicated test logic clock used serially to shift test instruction, test data, and control inputs on the rising edge of the clock, and serially to shift the output data on the falling edge of the the clock.}\\\hline
Test Data Input (TDI) & \multicolumn{1}{m{11cm}|}{Serial input for instruction and test data. Data is captured on the rising edge of the test logic clock. This pin is equipped with an internal pull-up resistor.}\\\hline
Test Data Output (TDO) & \multicolumn{1}{m{11cm}|}{Serial output for test instruction and data from the test logic. TDO is set to an Inactive Drive state (high impedance) when data scanning is not in progress.}\\\hline
Test Reset (TRST) & \multicolumn{1}{m{11cm}|}{Active-low input which asynchronously resets the test logic. This pin is equipped with an internal pull-up resistor.}\\\hline
\end{tabular}
\end{table}
\end{center}

\FloatBarrier
TRST overrides the behavior of the TMS and TCK. In other words, asserting TRST resets the TAP controller regardless of the the states of the TMS and TCK. Also, if TAP controller is held in the reset state, the state machine remains in the 'Test Logic Reset' condition.\cite{microsemi}

\subsubsection{TAP Controller}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{jtag_tap}
\label{jtag_tap}
\caption{TAP CONTROLLER \cite{fpga4fun}}
\end{figure}

The 16 states of the TAP controller finite state machine are shown in the Fig. 2. The 1s and 0s shown adjacent to the state transitions represent the TMS values that must be present at the time of a rising edge at TCK for a state transition to occur. In the states that include the letters -IR, the instruction register operates. In the states that include the letters -DR, the test data registers operates (bypass, boundary scan).\cite{TAPController}

By default, upon power up(or when TRST is asserted) the TAP controller enters the Test-Logic-Reset state. The TAP controller also has an inherent property for automatically reaching this state when the TMS signal is held high for atleast 5 clock signals.

The operation of each state is explained below\cite{TAPController}
\begin{itemize}[noitemsep]
\item \textbf{Test-Logic-Reset} \\All test logic is disabled in this controller state enabling the normal operation of the IC.
\item \textbf{Run-Test-Idle} \\In this controller state, the test logic in the IC is active only if certain instructions are present. For example, if an instruction activates the self test, then it is executed when the controller enters this state. The test logic in the IC is idle otherwise.
\item \textbf{Select-DR-Scan} \\This controller state controls whether to enter the Data Path or the Select-IR-Scan state.
\item \textbf{Select-IR-Scan} \\This controller state controls whether or not to enter the Instruction Path. The controller can return to the Test-Logic-Reset state otherwise.
\item \textbf{Capture-IR} \\In this controller state, the shift register bank in the Instruction register parallel loads a pattern of fixed values on the rising edge of TCK. The last two significant bits must always be '01'.
\item \textbf{Shift-IR} \\In this controller state, the instruction register gets connected between TDI and TDO, and the captured pattern gets shifted on each rising edge of TCK. The instruction available on the TDI pin is also shifted in on to the instruction register.
\item \textbf{Exit1-IR} \\This controller state controls whether to enter the Pause-IR state or Update-IR state.
\item \textbf{Pause-IR} \\This state allows the shifting of the instruction register to be temporarily halted.
\item \textbf{Exit2-IR} \\This controller state controls whether to enter either the Shift-IR state or Update-IR state.
\item \textbf{Update-IR} \\In this controller state, the instruction in the instruction register is latched to the latch bank of the Instruction Register on every falling edge of TCK. The instruction becomes the current instruction once it is latched.
\item \textbf{Capture-IR} \\In this controller state, the data is parallel-loaded into the data registers selected by the current instruction on the rising edge of TCK.
\item \textbf{Shift-DR, Exit1-DR, Pause-DR, Exit2-DR and Update-DR} \\These controller states are similar to the Shift-IR, Exit1-IR, Pause-IR, Exit2-IR and Update-IR states in the Instruction Path.\cite{TAPController}
\end{itemize}

\subsubsection{Registers}
\begin{description}
\item [$\bullet$ Instruction Register]
The instruction register allows an instruction to be shifted into the design. The instruction is used to select the test to be performed or the test data register to be accessed or both. Optionally, the instruction register allows examination of design-specific information generated within the component.

Each IR cell in the Instruction Register has a shift-register stage and a latch stage for fault isolation of the board-level serial test data path.\cite{microsemi}\cite{Osseiran}

%ADD IMAGE HERE
%\begin{figure}[ht]
%\centering
%\includegraphics[width=10cm,height=6cm]{instructionRegister}
%\caption{Instruction Register}
%\end{figure}

\begin{center}
\begin{table}[!h]
\caption{Supported Instructions\cite{microsemi}}
\label{table:IR}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{Instruction} & \multicolumn{1}{m{2cm}|}{\textbf{IR-Code (IR3-IR0)}} & \multicolumn{1}{m{2cm}|}{\textbf{Instruction Type}} & \textbf{Description} \\ \hline
 
 EXTEST & 0000 & Mandatory & \multicolumn{1}{m{7cm}|}{Allows testing of off-line circuitry and board-level interconnections}\\\hline
 
 SAMPLE/PRELOAD & 0001 & Mandatory & \multicolumn{1}{m{7cm}|}{Allows a snapshot of the normal operation of the component to be taken and examined}\\\hline

 IDCODE & 0010 & Optional & \multicolumn{1}{m{7cm}|}{32-bit hard-wired Manufacturer ID, part number, and version number}\\\hline

BYPASS & 1111 & Mandatory & \multicolumn{1}{m{7cm}|}{Provides minimum-length (1-bit) serial path between TDI and TDO pins of component when no test operation of that component is required}\\\hline

 INTEST & XXXX & Optional & \multicolumn{1}{m{7cm}|}{Allows testing of on-chip system logic while component is assembled on the board}\\\hline 

\end{tabular}
\end{table}
\end{center}

\FloatBarrier
\item [$\bullet$ Data Register]
\  \\

\begin{enumerate}[I]%for capital Roman numbers
\item Boundary-Scan Register
\ \\
The boundary-scan register allows testing of circuitry external to a component, for example, board interconnect or external components that do not conform to this standard. The register also permits the system signals flowing into and out of the system logic to be sampled and examined without causing interference with the normal (nontest) operation of the on-chip system logic. Optionally, additional test functions may be supported - for example, testing of the on-chip system logic.\cite{microsemi}

\item Bypass Register
\ \\
This provides a single-bit serial connection through the circuit when none of the other test data registers is selected. This register can, for example, be used to allow test data to flow through a particular device to other components in a product without affecting the normal operation of the particular component.\cite{microsemi}

\item Device Identification Register
\ \\
This is an optional test data register that allows the manufacturer, part number, and variant of a component to be determined.\cite{microsemi}

\end{enumerate} 

\end{description}


\subsection{Introduction to Verification Methodologies:}


\subsubsection{Classical verification vs Constraint based verification:\cite{doulos}}

With the increasing complexity of the digital systems, comes the need to have smarter ways to verify the functionality of the designed DUT. Initially the digital were tested with tediously written test-benches and then observing the respective waveform. The higher complexity did no longer allow for the manual checks and there was a need to automate the verification methods.\cite{doulos}

Verification planning and management involves identifying the features of the DUT that need to be verified, prioritizing those features, measuring progress, and adjusting the allocation of verification resources so that verification closure can be reached on the required timescale. The mechanics of verification can be accomplished using static formal verification in the context of UVM focuses on the simulation-based verification environment.\cite{doulos}

There are two contrasting approaches to coverage-driven verification in current use. "Classical" constrained random verification starts with random stimulus and gradually tightens the constraints until coverage goals are met, relying on brute power of randomization and compute server farms to cover the state farms to cover the state space. More recently, graph-based stimulus generation (also known as Intelligent Testbench) starts from an abstract description of the legal transitions between the high-level states of the DUT, and automatically enumerates the minimum set of tests needed to cover the paths through this state space. For many application, graph-based stimulus is able to achieve high coverage in far fewer cycles than "classical" constrained random. UVM directly supports constrained random, whereas graph-based stimulus generation requires a separate, dedicated tool. Stimulus generated from the graph-based approach can be executed on a UVM verification environment.\cite{doulos}

Functional coverage and code coverage measure different things. Code coverage measures the execution of the actual RTL code (which must therefore exist before the code coverage can run at all). The collection of code coverage information, including statement and branch coverage, state coverage, and state transition coverage, is largely automatic. Functional coverage, on the other hand, attempts to measure whether the features described in the verification plan have actually been executed by the DUT. The feature to be measured have to be decided from the specification and implementation of the design to create the verification plan, and so functional coverage can be considered as a qualitative measure of DUT code execution.\cite{doulos}

The best practice is to create a verification plan that consists of a list of features to be tested as opposed to a list of direct test descriptions. All stakeholders in the verification process should contribute to the identification and prioritization of features in the verification plan, since this feature set will form the foundation for the subsequent verification process.\cite{doulos}

\subsubsection{Advantages of Functional coverage}
Functional coverage helps to identify

\begin{itemize}[noitemsep]
\item the features in the verification plan that have been successfully tested
\item the features in the verification plan that have yet to be tested
\item the proportion of the features that have been tested and thus how close the verification process is to completion
\item the set of tests that provide maximum coverage using the minimum number of CPU cycles
\end{itemize}

In contrast, in traditional directed testing methodology, the absence of further bugs being detected is taken as evidence that verification is nearly complete. This may overcome some scenarios in which the DUT might fail.\cite{doulos}

\subsubsection{What is UVM?}
\ \\ 
\textbf{Introduction to UVM}
\ \\
UVM is a methodology for functional verification using SystemVerilog, complete with a supporting library of SystemVerilog code. UVM stands for Universal Verification Methodology. It was created by Accelera based on the OVM(Open Verification Methodology) version 2.1.1.

It is basically a methodology for the functional verification of digital hardware, primarily using simulation. The hardware or system would be typically be described using Verilog, SystemVerilog, VHDL or SystemC at any appropriate abstraction level. This could be behavioral, Register-transfer level, or gate level. UVM is explicitly simulation-oriented, but UVM can also be used alongside assertion-based verification, hardware acceleration or emulation.\cite{doulos1}
\ \\
\ \\
\textbf{History}
\ \\
In December 2009, a technical subcommittee of Accellera - a standards organization in the electronic design automation (EDA) industry - voted to establish the UVM and decided to base this new standard on OVM 2.1.1, a verification methodology developed jointly in 2007 by Cadence Design Systems and Mentor Graphics.
In February 21, 2011, Accelera approved the 1.0 version of UVM. It included a Reference Guide, a Reference Implementation in the form of SystemVerilog base class library, and a User Guide.\cite{UVMWiki}
\ \\
\ \\
\textbf{Checkers, Coverage and Constraints}
\ \\
Constrained random verification relies on Checkers, Coverage and Constraints and these are supported by explicit features of the SystemVerilog language.\cite{doulos1}

Firstly, checkers ensure functional correctness. Nothing is gained by throwing more and more random stimulus into a design to take functional coverage to ever higher levels unless the design-under test is being checked automatically for functional correctness. Checkers can be implemented by SystemVerilog assertions or using regular procedural code. UVM provides mechanisms and guidelines for building checkers into the verification environment and for logging reports.\cite{doulos1}

Secondly, coverage provides a measure of the functional completeness of the testing, and tells us when we have met the goals set out in the verification plan, and thus when you have finished simulating. SystemVerilog offers two separate mechanisms for functional coverage collection; property-based coverage (cover directives) and sample-based coverage (covergroups). Both can be used in a UVM verification environment. The specification and the execution of the coverage information is intimately tied to the verification plan, and many simulation tools are able to annotate coverage information onto the verification plan document, facilitating tight management control.\cite{doulos1}

Thirdly, constraints provide the means to reach coverage goals by shaping the random stimulus to push the DUT into interesting corner cases. Without shaping, random stimulus alone may be insufficient to exercise many of the deeper states of the DUT. Constrained random stimulus is still random, but the statistical distribution of the vectors is shaped to ensure that interesting cases are reached. Systemverilog has dedicated language features for expressing constraints, and UVM goes further by providing mechanisms that allow constraints to be written as a part of a test rather than embedded within verification components. this and other features of UVM facilitate the creating of reusable verification components.\cite{doulos1}
\ \\
\ \\
\textbf{Verification Reuse}
\ \\
UVM facilitates the construction of verification environments and tests, both by providing reusable machinery in the form of a library of SystemVerilog classes, and alos by providing a set of guidelines for best practice when using SystemVerilog for verification.\cite{doulos1}

Verification productivity can be enhanced by reusing verification components, and this is an an important objective of UVM. Verification reuse is enabled by having a modular verification environment where each component has clearly defined responsibilities, by allowing flexibility in the wat in which components are configured and used, by having a mechanism to allow imported components to be customized to the application at hand, and by having well-defined coding guidelines to ensure consistency.\cite{doulos1}

The architecture of UVM has been designed to encourage modular and layered verification environments, where verification components at all layers can be reused in different environments. Low-level driver and monitor components can be reused across multiple DUT. The whole verification environment can be reused by multiple tests and configured top-down by those tests. Finally, test scenarios can be reused from application to application. This degree of reuse is enabled by having UVM verification components able to be configured in a very flexible way without modification to their source code. This flexibility is built into the UVM class library.\cite{doulos1}

%===============================================================================================================
\newpage
\pagebreak
\section{Literature Survey}

\textbf{Blocks in UVM}
\ \\
We have a DUT and to test the functionality we have to simulate it. To achieve this, we will need a block that generates sequences of bits to be transmitted to the DUT. This block in UVM is called the \textit{Sequencer}.

Usually the sequencer is unaware of the communication bus and the physical connections to the DUT. The sequencer is responsible only for generating generic sequences of data and then it is sent to another block that has direct access to the physical pins of the DUT. This block that interacts directly with the DUT is called the \textit{Driver}.\cite{colorlesscube}

While the driver maintains activity with the DUT by feeding it data generated from the sequencers, it does not validate the applied stimuli. We need a block that will listen to the communication between the driver and the DUT. This block is called the \textit{Monitor}. Monitors sample the inputs/outputs of the DUT.

The monitor tries to make a prediction of the expected result and send the prediction and result of the DUT to another block of UVM. This block, the \textit{Scoreboard}, compares and evaluates these data from the monitor.

All these blocks together constitute a typical system used for verification and the same structure is used in UVM testbenches.

Usually the sequence, the sequencer, the driver and the monitor compose an \textit{Agent}. An agent together with the scoreboard constitute an \textit{Environment}. All these blocks are controlled by a greater block denominated by \textit{Test}. The test block controls all the blocks and sub blocks of the testbench. By changing just a few lines of code, we could add, remove and override blocks in our testbench and build different environments without rewriting the whole test.\cite{colorlesscube}
\ \\
\ \\
\textbf{UVM classes}
\ \\

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{introClassTree}
\label{fig:UVM Class Tree}
\caption{UVM Class Tree\cite{colorlesscube}}
\end{figure}

The re-usability is one of the great advantages of UVM. This is mainly due to the concept of classes and objects from SystemVerilog.

In UVM, all the above mentioned blocks are represented as objects that are derived from the already existing classes.

A class tree of the most important UVM classes can be seen in the fig.3.

The data that travels to and from the DUT is stored in \textit{uvm\textunderscore sequence\textunderscore item} and \textit{uvm\textunderscore sequence}. The sequencer is derived from the \textit{uvm\textunderscore sequencer}, the driver is derived from the \textit{uvm\textunderscore driver} and so on.\cite{colorlesscube}
\ \\
\ \\
\textbf{UVM Phases}\cite{colorlesscube}
\ \\

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=2cm,height=4cm]{uvmPhases}
\caption{Instruction Register\cite{colorlesscube}}
\end{figure}

All the above mentioned classes have simulation phases. Phases are ordered steps of execution implemented as methods. When we derive a new class, the simulation of our testbench goes through these different steps in order to construct, configure and connect the testbench.\cite{colorlesscube}

\begin{itemize}

\item Build Phase:
\ \\
The build phase is used to construct components of the hierarchy. For example, the build phase of the agent class will construct the classes for the monitor, for the sequencer and for the driver.

\item Connect Phase:
\ \\
The connect is used to connect the different sub components of a class. Using the same example, the connect phase of the agent connects the driver to the sequencer and the monitor is connected to an external port.

\item Run Phase:
\ \\
The run phase is the main phase of the execution. This is where the actual code of a simulation will execute.

\item Report Phase:
\ \\
Finally, the report phase is the phase where the results of the simulation are displayed.\cite{colorlesscube}

\end{itemize}
\ \\
\ \\
\textbf{UVM Macros}\cite{colorlesscube}
\ \\
Macros are an important aspect of UVM. These macros implement some useful methods in classes and in variables. Though they are optional to use, using them simplifies the process of code development and testing.\cite{colorlesscube}

The most common ones are:
\begin{itemize}

\item `uvm\textunderscore component\textunderscore utils
\ \\
This macro registers the new class type. It is used when deriving new classes like a new agent, driver, monitor and so on.

\item `uvm\textunderscore field\textunderscore init
\ \\
This macro registers a variable in the UVM factory and implements some functions like copy(), compare() and print().

\item `uvm\textunderscore info
\ \\
This is a very useful macro which we have used to print messages from the UVM environment during simulation time.\cite{colorlesscube}


\end{itemize}


%===============================================================================================================
\newpage
\pagebreak
\section{Objective and Specifications}

Development of a Universal Verification Methodology environment of the JTAG interface. It will contain the following functionality:

\begin{itemize}
\item Existing and verified IP core of a JTAG interface
\item Execution of the following Instructions: \\EXTEST, INTEST, SAMPLE/PRELOAD, BYPASS, IDCODE according to IEEE1149.1 standard
\item Enhanced test bench(es) to fully test the DUT
\end{itemize}

The simulation runs as well as the occurring challenges are documented.
\\ \textbf{IDE used:} Questa\textregistered Advanced Simulator, Mentor Graphics

%===============================================================================================================
\newpage
\pagebreak
\section{Developed Modules:}

\subsection{Device Under Test with JTAG capability}
The designed DUT is JTAG compliant. The objective of our project is to develop a UVM Test for a JTAG interface. We would design a basic full adder with JTAG capabilities. The full adder module can be replaced with any other DUTs and the same testbench would implement the same JTAG tests accurately.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=10cm]{AdvancedDut}
\caption{Developed Design Under Test}
\label{fig:developed DUT}
\end{figure}

\FloatBarrier
\subsubsection{Boundary Scan Cells Modules}
\underline{\textbf{Located in:} \textit{InputCell.v} and \textit{OutputCell.v}}\\

The boundary-scan test architecture provides a means to test interconnects between integrated circuits on a board without using physical test probes. It adds a boundary-scan cell that includes a multiplexer and latches to each pin on the device. Boundary-scan cells in a device can capture data from pin or core logic signals, or force data onto pins. Captured data is serially shifted out and externally compared to the expected results. Forced test data is serially shifted into the boundary-scan cells. All of this is controlled from a serial data path called the scan path or scan chain. Figure 1 depicts the main elements of a boundary-scan cell. By allowing direct access to nets, boundary-scan eliminates the need for a large number of test vectors, which are normally needed to properly initialize sequential logic. Tens or hundreds of vectors may do the job that had previously required thousands of vectors. Potential benefits realized from the use of boundary-scan are shorter test times, higher test coverage, increased diagnostic capability and lower capital equipment cost.

Data is passed serially through the Boundary Scan Registers which help in debugging the state of the inputs and the outputs.

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=10cm,height=6cm]{BoundaryScanCell}
\caption{Boundary Scan Cell \cite{corelis}}
\label{fig:Boundary Scan Cell}
\end{figure}

\textbf{Output Boundary Scan Cell:}
This is the Boundary Scan Cell that is connected to the output side of the Full Adder Module. When the DUT is running in JTAG mode, then the TDI and TDO are connected between the boundary scan registers and this path is called the 'Scan Path'. The JTAG mode, the value in the instruction register decides the flow of information from the Scan Path. In normal operation mode, these boundary scan cells pass the Full Adder outputs to the outputs of the DUT.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
module OutputCell( FromCore, FromPreviousBSCell, CaptureDR, ShiftDR, 
UpdateDR, extest, TCK, ToNextBSCell, TristatedPin);
input  FromCore;
input  FromPreviousBSCell;
input  CaptureDR;
input  ShiftDR;
input  UpdateDR;
input  extest;
input  TCK;
output ToNextBSCell;
output TristatedPin;
}
\end{lstlisting}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=7cm,height=4cm]{OutputDUT}
\caption{Output Section of the DUT}
\label{fig: Output DUT}
\end{figure}

\FloatBarrier
\textbf{Input Boundary Scan Cell:}
This is the Boundary Scan Cell that is connected to the output side of the Full Adder Module. In normal operation mode, these boundary scan cells pass the input given to the DUT to the Full Adder input ports. The JTAG mode, the value in the instruction register decides the flow of information from the Scan Path.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
module InputCell( InputPin, FromPreviousBSCell, CaptureDR, ShiftDR, 
UpdateDR, TCK, ToNextBSCell, ToCore);
input  InputPin;
input  FromPreviousBSCell;
input  CaptureDR;
input  ShiftDR; 
input  UpdateDR;
input  TCK;
output ToNextBSCell;
output ToCore; 
\end{lstlisting}

%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=7cm,height=4cm]{InputDUT}
\caption{Input Section of the DUT}
\label{fig: Input DUT}
\end{figure}

In addition to the parallel in, parallel out, serial in and serial out lines, the captureDR, ShiftDR, UpdateDR and TCK pins are also passed to this module from the TAP controller module. These signals indicate the Boundary Scan of the mode in which the DUT is operating in.

InputCell.v and OutputCell.v are the files that contain the input boundary scan cell and output boundary scan cell respectively.


\FloatBarrier
\subsubsection{TAP Controller Module}
\underline{\textbf{Located in:} \textit{tap\_top.v}}\\

The TAP controller module controls all the operation of the DUT when in the JTAG test operation mode. The TCK, TDI, TRST and TMS are the inputs to this module. The TDO pin is the output from this module. The TAP controller also contains the instruction register, the BYPASS register and the IDCODE register.

When the instruction register contains the instruction for IDCODE operation, the TDI and TDO are connected between the IDCODE registers. On every falling edge of the TCK signal, the IDCODE register is shifted out bit by bit to the TDO pin.

The BYPASS register is a one bit register that is connected between the TDI and TDO pin when the BYPASS instruction is selected. So the TDO follows the TDI with one clock cycle delay.

The operation of the TAP controller is controlled by the TMS pin. Fig. 2 shows how the TAP controller states change. The Finite-State Machine for the TAP controller has been implemented and tested.


\FloatBarrier
\subsubsection{Full Adder Module}
\underline{\textbf{Located in:} \textit{full\_adder.v}}\\

The full adder module implements the basic operations of the Full adder. It has three inputs and Sum and Carry outputs. This module is written in the full\_ addder.v file.\\

\underline{Ports of the full adder:}
\begin{itemize}[noitemsep]
\item A - input
\item B - input
\item Cin - input
\item Sum - output
\item Cout - output
\end{itemize}

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
module full_adder(
  input_a,
  input_b,
  input_cin,
	
  output_sum_o,
  output_cout_o
);

input input_a;
input input_b;
input input_cin;

output output_sum_o;
output output_cout_o;

reg output_sum;
reg output_cout;

assign output_sum_o = output_sum;
assign output_cout_o = output_cout;

always @(*) begin
  {output_cout, output_sum} <= input_cin + input_a + input_b;
end

endmodule
\end{lstlisting}
%===============================================================================================================
\FloatBarrier
\subsection{UVM Modules}
This contains all the modules that are required for the verification environment
%ADD IMAGE HERE
\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{phaseZEnvironment}
\caption{Designed Verification Environment}
\label{fig: Designed Verification Environment}
\end{figure}

Each of these blocks are explained in detail below. It also contains actual snapshots of the code for easier understanding.

\FloatBarrier
\subsubsection{Top Block}
\underline{\textbf{Located in:} \textit{testbench.sv}}\\

Generally the development of the DUT is done independently of the development of the testbench environment. The testbench top module connects the DUT to the verification components. A virtual interface is defined and added to the database so that all the modules that have access to the DUT can invoke it from the database.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
module top;
  import uvm_pkg::*;
  import my_testbench_pkg::*;
  
  // Instantiate the interface
  dut_if dut_if1();
  
  // Instantiate the DUT and connect it to the interface
  dut dut1(.dif(dut_if1));
  
  // Clock generator
  initial begin
    dut_if1.TCK = 0;
    forever #5 dut_if1.TCK = ~dut_if1.TCK;
  end
  
  initial begin
    // Place the interface into the UVM configuration database
    uvm_config_db#(virtual dut_if)::set(null, "*", "dut_vif", dut_if1);
    // Start the test
    run_test("my_test");
  end
  
  // Dump waves
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars(0, top);
  end
  
endmodule
\end{lstlisting}

The Top contains the following:

\begin{itemize}[noitemsep]
\item DUT Instance
\item Interface instance
\item Clock Generator block
\item start the test
\item set config\_db
\item waveform dump logic
\end{itemize}
 

%\FloatBarrier
\subsubsection{Test Block}
\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The test file is derived from the uvm\_test class. The test defines the test scenario for the testbench. It contains the environment, configuration properties, class overrides etc. A sequence can also be connected from this block. This test block runs when the run\_test() function is called. Here, the test also defines the environment.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]

class my_test extends uvm_test;
  `uvm_component_utils(my_test)

  my_env env;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    env = my_env::type_id::create("env", this);
  endfunction

  task run_phase(uvm_phase phase);
    // We raise objection to keep the test from completing
    phase.raise_objection(this);  
    #10;
    `uvm_warning("", "Task Started! Ready for Lift-off!")
    // We drop objection to allow the test to complete
    phase.drop_objection(this);  
  endtask
endclass: my_test
\end{lstlisting}

\FloatBarrier
\subsubsection{Environment Block}
\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The environment is derived from the uvm\_env class. The environment defines the Agent and the Scoreboard in the build phase. In the connect phase, the outputs from the monitor are connected to the scoreboard.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class my_env extends uvm_env;
  `uvm_component_utils(my_env)

  my_agent agent;
  jtag_scoreboard mem_scb;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
		
  function void build_phase(uvm_phase phase);
    agent   = my_agent::type_id::create("agent", this);
    mem_scb = jtag_scoreboard::type_id::create("mem_scb", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    agent.mon_before.mon_ap_before.connect(mem_scb.sb_export_before);
    agent.mon_after.mon_ap_after.connect(mem_scb.sb_export_after);
  endfunction : connect_phase
endclass: my_env
\end{lstlisting}

\FloatBarrier
\subsubsection{Agent Block}

\underline{\textbf{Located in:} \textit{my\_testbench\_pkg.svh}}\\

The build phase of the driver executes the following commands:
\begin{itemize}[noitemsep]
\item Instantiate the ports that are used to connect to the monitor
\item Instantiate the sequencer block
\item Instantiate the agent block
\item Instantiate the monitor block for reading TDI 
\item Instantiate the monitor block for reading TDO
\end{itemize}

The connect phase of the driver executes the following commands:
\begin{itemize}[noitemsep]
\item The seq\_item\_port of the driver is connected to the seq\_item\_export of the sequencer
\item The uvm\_analysis\_port of TDI monitor is connected to the uvm\_analysis\_port of the agent
\item The uvm\_analysis\_port of TDO monitor is connected to the uvm\_analysis\_port of the agent
\end{itemize}

The agent also contains the following blocks:
\begin{itemize}[noitemsep]
\item Sequence or Transaction Block
\item Sequencer Block
\item Driver Block
\item Monitors Block
\end{itemize}
These blocks and their snapshots are explained more in detail further.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class my_agent extends uvm_agent;
  `uvm_component_utils(my_agent)

  uvm_analysis_port#(my_transaction) agent_ap_before;
  uvm_analysis_port#(my_transaction) agent_ap_after;
	
  jtag_monitor_before  mon_before;
  jtag_monitor_after   mon_after ;
  my_driver driver;
  uvm_sequencer#(my_transaction) sequencer;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  // Build Phase
  //The build phase instanciates all the modules built inside the agent
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
		
    agent_ap_before = new("agent_ap_before", this);
    agent_ap_after  = new("agent_ap_after", this);;
		
    sequencer = uvm_sequencer#(my_transaction)::type_id::create("sequencer", this);
    driver = my_driver ::type_id::create("driver", this);
    mon_before = jtag_monitor_before::type_id::create("mon_before", this);
    mon_after = jtag_monitor_after::type_id::create("mon_after", this);		
  endfunction : build_phase

  // Connect Phase
  //interconnection between the modules
  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);		
    driver.seq_item_port.connect(sequencer.seq_item_export);		
    mon_after.mon_ap_after.connect(agent_ap_after);
    mon_before.mon_ap_before.connect(agent_ap_before);		
  endfunction

  // Run Phase
  task run_phase(uvm_phase phase);	
    // We raise objection to keep the test from completing
    phase.raise_objection(this);  
    begin
      my_sequence seq;
      seq = my_sequence::type_id::create("seq");
      seq.start(sequencer);
    end	
    // We drop objection to allow the test to complete
    phase.drop_objection(this);  
  endtask
endclass: my_agent
\end{lstlisting}

\FloatBarrier
\paragraph{Sequence or Transaction Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The first step in testing our RTL design is to decide what kind of transaction is to be passed to the Driver. The transaction is designed by extending the uvm\_ sequence\_ item class. This includes the information needed to model the communication between the UVM components.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class my_transaction extends uvm_sequence_item;

  `uvm_object_utils(my_transaction)

  rand bit tms;
  rand bit tdi;
  rand bit trstn;
  rand bit tdo;
  rand bit A;
  rand bit B;
  rand bit Cin;

  function new (string name = "");
    super.new(name);
  endfunction
endclass: my_transaction
\end{lstlisting}

\FloatBarrier
\paragraph{Sequencer Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

After a basic transaction has been defined, the verification environment will need to generate a collection of them and get them ready to be sent to the driver. This is the job of the sequencer. Sequencer is extended from the uvm\_ sequence and its main job is to generate multiple transactions. Sequences are an ordered collection of transactions and they shape transactions to our needs and also generate as many as we need. We could also constrain the range of randomization to the valid range to reduce simulation time in invalid values. 
These transactions are then transferred to the driver module.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class my_sequence extends uvm_sequence#(my_transaction);

  `uvm_object_utils(my_sequence)

  function new (string name = "");
    super.new(name);
  endfunction

  integer numberOfRequests = 0;

  task body;
    numberOfRequests = 150 + `DATA_LENGTH;
    repeat(numberOfRequests)
    begin
      req = my_transaction::type_id::create("req");

      start_item(req);
      if(!req.randomize())
      begin
        `uvm_warning("", "Randomization failed!")
      end
      // Waiting for the driver to send the item_done() command
      finish_item(req);  
    end
  endtask: body
endclass: my_sequence
\end{lstlisting}

\FloatBarrier
\paragraph{Driver Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The role of the driver block is to directly interact with the DUT. The driver pulls transactions from the sequencer and sends them repetitively to the signal-level interface. This interaction will be observed and evaluated by another block, the monitor. The driver toggles the TMS and the TDI pins to traverse through the TAP controller. The values of the TDI are shifted into the IR or the DR register depending on the state of the TAP controller. The driver module is extended from the uvm\_ driver class.
The run phase of the driver does the following:

\begin{itemize}[noitemsep]
\item Gets a sequence item from sequencer
\item Drive the sequence item to the DUT
\item Wait for a possible few clock cycles for the DUT to respond
\item Tell the sequencer that the current process is complete
\item Ask the sequencer to send the next sequence item
\end{itemize}

The config\_db places the defined virtual interface in the database so that it can be accessed by the driver module. Using the similar process, the interface can be loaded into any block which accesses the DUT directly.\\

\underline{\textbf{UVM Driver Methods:}}\\
\textbf{get\_next\_item} \\This method blocks the driver till a sequence\_item is available at the sequencer\\
\textbf{item\_done} \\The non-blocking item\_done()method will return a null pointer if there is no sequence\_item available in the sequencer.
\\
 \\
\underline{\textbf{Tests implemented in the driver:}}\\

\begin{itemize}[noitemsep]

\item Bypass Instruction
\item Idcode Instruction
\item Intest Instruction
\item Sample/Preload Instruction

\end{itemize}

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class my_driver extends uvm_driver #(my_transaction);
  `uvm_component_utils(my_driver)
  virtual dut_if dut_vif;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    // Get interface reference from config database
    if(!uvm_config_db#(virtual dut_if)::get(this, "", "dut_vif", dut_vif)) 
    begin
      `uvm_error("", "uvm_config_db::get failed")
    end
    else
    begin
      `uvm_warning("", "Configuration database successfully accessed!")
    end
  endfunction 

  task run_phase(uvm_phase phase);(...)
  endtask

  virtual function void compareForBypass();(...)
  endfunction: compareForBypass

  virtual function void compareForIdcode();(...)
  endfunction: compareForIdcode

  virtual function void printForExtestFullAdder();(...)
  endfunction: printForExtestFullAdder

  virtual function void printSamplePreload();(...)
  endfunction: printSamplePreload

  virtual function void printIntest();(...)
  endfunction : printIntest

  virtual function void printExtest();(...)
  endfunction

endclass: my_driver
\end{lstlisting}

\FloatBarrier
\paragraph{Monitors Block}\mbox{}\\
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\
The monitor is derived from the uvm\_monitor. Monitor is a passive block that observes the communication of the DUT with the verification environment. The monitor also returns an error if the response of the DUT does not match with the expected results. It is passive because it does not drive any signals to the DUT. The monitor samples the DUT signals through the virtual interface and converts the signal level activity to transaction level activity.

Monitor uses TLM ports to point to the DUT signals. There are two monitors that have been defined in out verification environment. One monitor is used to sample the inputs that are driven from the driver to the DUT( TDI ). The second monitor samples the response of the DUT (TDO) and converts in into transaction level activity. All these are written to the scoreboard.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class jtag_monitor_before extends uvm_monitor;
  `uvm_component_utils(jtag_monitor_before)

  uvm_analysis_port#(my_transaction) mon_ap_before;
 
  virtual dut_if dut_vif;
	
  reg [1:0] clock_value ;
  integer tdiScan =0;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction: new
 
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    mon_ap_before = new("mon_ap_before", this);		  
    if (! uvm_config_db #(virtual dut_if) :: get (this, "", "dut_vif", dut_vif)) begin
      `uvm_error (get_type_name (), "DUT interface not found")
    end         
  endfunction: build_phase

  task run_phase(uvm_phase phase);
    my_transaction sa_tx;
    sa_tx = my_transaction::type_id::create(.name("sa_tx"), .contxt(get_full_name()));

    //Writing the data at every toggling of the TDI pin
    forever begin
      @(posedge dut_vif.TCK)
      begin
        if(startValiadation_bypass)
        begin
          sa_tx.tdi = dut_vif.TDI;
          // This instruction writes the data to the scoreboard
          mon_ap_before.write(sa_tx); 
          validationBufferTDI_bypass[tdiScan]=dut_vif.TDI; 
          tdiScan++;
        end
      end			
    end
  endtask: run_phase
endclass: jtag_monitor_before
\end{lstlisting}

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class jtag_monitor_after extends uvm_monitor;
  `uvm_component_utils(jtag_monitor_after)
 
  uvm_analysis_port#(my_transaction) mon_ap_after;
 
  virtual dut_if dut_vif;

  reg [1:0] clock_value ;
  integer tdoScan_bypass =0;
  integer tdoScan_idcode =0;
  integer tdoScan_intest =0;
  integer tdoScan_extest =0;


  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction: new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    mon_ap_after = new(.name("mon_ap_before"), .parent(this));
    if (! uvm_config_db #(virtual dut_if) :: get (this, "", "dut_vif", dut_vif)) 
    begin
      `uvm_error (get_type_name (), "DUT interface not found")		
    end
  endfunction: build_phase

  task run_phase(uvm_phase phase);
    my_transaction sa_tx_after;
    sa_tx_after = my_transaction::type_id::create(.name("sa_tx_after"), .contxt(get_full_name()));

    forever begin
      @(negedge dut_vif.TCK)
      begin					
        if(startValiadation_bypass == 1)
        begin
          sa_tx_after.tdo = dut_vif.TDO;
          mon_ap_after.write(sa_tx_after);
          validationBufferTDO_bypass[tdoScan_bypass]=dut_vif.TDO;
          tdoScan_bypass++;
        end

        if(startValiadation_idcode == 1)
        begin
          sa_tx_after.tdo = dut_vif.TDO;
          mon_ap_after.write(sa_tx_after);
          validationBufferTDO_idcode[tdoScan_idcode]=dut_vif.TDO;
          tdoScan_idcode++;
        end

        if(startValiadation_intest == 1)
        begin
          sa_tx_after.tdo = dut_vif.TDO;
          mon_ap_after.write(sa_tx_after);
          validationBufferTDO_intest[tdoScan_intest]=dut_vif.TDO;
          tdoScan_intest++;
        end
      end
    end
  endtask: run_phase
endclass: jtag_monitor_after
\end{lstlisting}

\FloatBarrier
\subsubsection{Scoreboard Block}
\underline{\textbf{Located in:} \textit{my\_sequence.svh}}\\

The scoreboard module is extended from the uvm\_scoreboard class. uvm\_scoreboard is inherited by uvm\_component. The signals from the monitors are connected to the scoreboard.

\begin{lstlisting}[style={verilog-style}, backgroundcolor=\color{lightgray}]
class jtag_scoreboard extends uvm_scoreboard;
  `uvm_component_utils(jtag_scoreboard)
	
  uvm_analysis_export #(my_transaction) sb_export_before;
  uvm_analysis_export #(my_transaction) sb_export_after;
	
  uvm_tlm_analysis_fifo #(my_transaction) before_fifo;
  uvm_tlm_analysis_fifo #(my_transaction) after_fifo;
	
  my_transaction transaction_before;
  my_transaction transaction_after;
	
  function new(string name, uvm_component parent);
    super.new(name, parent);
    transaction_before = new("transaction_before");
    transaction_after = new("transaction_after");
  endfunction: new
	
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    sb_export_before = new("sb_export_before", this);
    sb_export_after  = new("sb_export_after",  this);
		
    before_fifo = new("before_fifo", this);
    after_fifo  = new("after_fifo",  this);
  endfunction: build_phase
	
  function void connect_phase(uvm_phase phase);
    sb_export_before.connect(before_fifo.analysis_export);
    sb_export_after.connect(after_fifo.analysis_export);
  endfunction: connect_phase
	
  task run();
    forever begin
      before_fifo.get(transaction_before);
      after_fifo.get(transaction_after);
    end
  endtask: run
endclass: jtag_scoreboard
\end{lstlisting}

%===============================================================================================================
\FloatBarrier
\newpage
\pagebreak

\section{Testing and Debugging Phases}
\subsection{Phase I: Basic communication}
In this phase, the DUT that we use is a dummy DUT. Its only work is to print out the data as it receives it. The interface of the DUT is similar to that of an 8-bit memory block with data address and data registers. A transaction is defined and a sequence is passed to a sequencer. This sequence then calls on to the driver to access the DUT. The environment used to develop the code is EDAPlayground. EDAPlayground is an online simulator where there is no download required to run the code. For initial testing, this was easier to use as the samples codes are readily available. The complete environment is shown in Fig. \ref{fig: Phase I testing enviroment}.
The work-flow is given below:

\begin{itemize}[noitemsep]
\item Classes for sequence, sequencer and driver are written
\item UVM builds, connects and runs these classes
\item A transaction is created
\item A randomized and constrained sequence (address and data) is sent to the DUT
\item Sequencer sends the sequence to the Driver and waits for item\textunderscore done signal from the driver
\item Driver toggles these data on to the DUT through the interface and then sends item\textunderscore done signal to the sequencer
\item UVM reporting is activated as long as the system does not receive a reset signal
\item Repeat sending sequences to the driver and observe the signals
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase1Environment}
\caption{Phase 1 Testing Environment\\Here the UVM environment is connected to the designed DUT}
\label{fig: Phase I testing enviroment}
\end{figure}

\subsubsection{Testing Results for Phase I}

\begin{figure}[ht]
\centering
\includegraphics[width=16cm,height=2cm]{images/testing1}
\caption{Phase I testing}
\label{fig: Phase I Testing}
\end{figure}

The system reset is held low and normal operations are let to run. Randomized data and address is sent. From the waveform in Fig.\ref{fig: Phase I Testing}, we can see that these signals are toggling with the input. The input parameters are randomized using the default \textit{randomize()} command in SystemVerilog. The input to the DUT here is a 8-bit data bus and the constraint on the value of the input is from 0 to 255. 

\subsubsection{Testing Conclusion for Phase I}
With this we have established a one-directional communication with our DUT. Also, the UVM Phases(build, connect, run and report) were tested. Our further developments have been built upon this basic building blocks. Here, we have not yet connected a monitor and scoreboard block. This would be included in phase III.
\ \\
\FloatBarrier
\subsection{Phase II: Adding TAP controller DUT}

Phase 2 development was built over the existing architecture in Phase 1. Here we have replaced the dummy DUT with a DUT that has a TAP controller inbuilt into it. The development environment was now changed from the EDAPlayground to the QuestaSim IDE. The codes from the EDAPlayground examples however do not run as it is on QuestaSim. The environment variables for the UVM library have to be properly defined and we have to take care of the \`includes in our program. \textit{import uvm\_pkg::*;} has be included as can be seen from the files in the project. The representation of the environment is shown in Fig. \ref{fig: Phase II Environment}.

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=7cm]{images/phase2Environment}
\caption{Phase II Environment: TAP Controller DUT added}
\label{fig: Phase II Environment}
\end{figure}
\FloatBarrier
\subsubsection{Testing Results for Phase II}

\paragraph{BYPASS Instruction test}\mbox{}\\
 \\\underline{Steps in which the BYPASS Instruction is executed:}
\begin{itemize}[noitemsep]
\item Move through the TAP controller states and reach the SHIFT IR state.
\item Shift-in the BYPASS instruction(4\'b1111) into the Instruction register. This means that the TAP controller remains at the SHIFT IR for 4 clock cycles. The value of TMS will be held to 0. TDI will be held to 1 to send in 4'b1111 into the IR. This will inform the TAP controller that the BYPASS instruction is to be executed
\item Move out of the Instruction Register state and navigate through the TAP controller states to reach the SHIFT DR state.
\item Now for every clock cycle, TDO will follow the data from TDI with a delay of one clock cycle. This one clock cycle delay is because of the addition of 1-bit Bypass register in the chain between TDI and TDO. In the VC we pass random signals to TDI and compare the same with the signals observed at TDO.
\end{itemize}

The selection of the Bypass instruction is done by declaring \textit{`define BYPASS\_INSTR}.\\ \underline{Note:} Do not run two tests simultaneously. \\
The tests for the bypass instruction are added in the run phase of the driver. The comments in the code mention exactly what each step does. Variable data stream length can be defined. A global variable \textit{DATA\_LENGTH} is defined in the \textit{my\_sequence.svh} file. The value will correspond to the length of the data stream that is sent from the TDI to the TDO. \\
 \\
The values of the TDI and TDO are stored by the monitor and then written into the scoreboard. The function \textit{compareForBypass()} compares the TDI and TDO values and the result is printed in the console of the QuestaSim during simulation. \\
 \\
 To introduce error into the bypass instruction the variable \textit{introduceErrorBypass} should be set to 1. This introduces a stuck-at-1 error at TDO pin. The function \textit{compareForBypass()} compares the two data streams and gives out an error on the console as the TDO and the TDI values do not match.\\

\begin{sidewaysfigure}[ht]
\centering
\includegraphics[width=\textwidth, height=13cm]{images/phase2_bypass}
\caption{BYPASS testing.\\ The TDO follows the TDI with a one clock cycle delay}
\label{fig:Bypass LandscapeFigure}
\end{sidewaysfigure}

\FloatBarrier
\paragraph{IDCODE Instruction test}\mbox{}\\
\underline{Steps in which the IDCODE Instruction is executed:}
\begin{itemize}[noitemsep]
\item Move through the TAP controller states and reach the SHIFT IR state.
\item Shift-in the IDCODE instruction(4\'b0010) into the Instruction register. This means that the TAP controller remains at the SHIFT IR for 4 clock cycles. The value of TMS will be held to 0. TDI will be 0 for the 1st clock cycle. 1 for the next clock cycle and 0 for the 3rd and the 4th clock cycle. This will inform the TAP controller that the IDCODE instruction is to be executed
\item Move out of the Instruction Register state and navigate through the TAP controller states to reach the SHIFT DR state.
\item The IDCODE register is a 32-bit register which is defined in a TAP controller. This contains a unique ID that used to identify it. Now for every clock cycle in the SHIFT DR state, this IDCODE register is connected between the TDO and the TDI. The IDCODE is shifted out serially.
\end{itemize}

The selection of the Idcode instruction is done by declaring \textit{`define IDCODE\_INSTR}.\\
The tests for the IDCODE are also defined in the run phase of the driver. The comments in the code mention exactly what each step does. Here, variable data streams cannot be defined as the length of the IDCODE register is defined in the IEEE Standard 1149.1\\
 \\
The values of the TDI and TDO are stored by the monitor and then written into the scoreboard. The function \textit{compareForIdcode()} compares the TDO values with the values of the IDCODE defined in the DUT . The result is printed in the console of the QuestaSim during simulation. Incase of an error, the IDCODE that is read by the verification environment is also printed out on the console. \\
 \\
 To introduce error into the IDCODE instruction the variable \textit{introduceErrorIdcode} should be set to 1. This introduces an error in the value that is read from the IDCODE register. The function \textit{compareForIdcode()} compares the two data streams and gives out an error on the console as the TDO values and the IDCODE register values do not match. The waveforms are shown in Fig. \ref{fig:IDCODE LandscapeFigure}

\newpage
\pagebreak

\begin{sidewaysfigure}[ht]
\centering
\includegraphics[width=\textwidth, height=13cm]{images/phase2_idcode}
\caption{IDCODE testing\\a. 32 bit IDCODE is shifted out to the TDO. This can be verified from the waveform.\\b. The IDCODE of the DUT is h149511c3}
\label{fig:IDCODE LandscapeFigure}
\end{sidewaysfigure}

\FloatBarrier
\subsubsection{Testing Conclusion for Phase II}
The TAP controller states can now be navigated through easily. For the further development we have a concrete understanding of how the algorithm works. Also, we have tested the operations of the BYPASS and the IDCODE instructions. All the testing so far, however, has been done using the waveforms of the QuestaSim IDE. To improve the readability and usability of the testbench, we will be implementing monitors and scoreboards.


%problems faced
\FloatBarrier
\subsection{Phase III: Adding Monitor and Scoreboard}
Two monitors are added to the UVM environment. The first is connected to the TDI input and the second is connected to the TDO output. These information are also written to the scoreboard. The changes that are made to the environment are as shown in Fig. \ref{fig:Phase III Environment}.

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase3Environment}
\caption{Phase III Environment: with Monitors and Scoreboard}
\label{fig:Phase III Environment}
\end{figure}

\subsubsection{Testing Results for Phase III}

Functions are written that read the information that is received by both the monitors and compares the two. \textit{compareForBypass() and compareForIdcode()} compares these information and invokes the uvm\_error functions.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth,height=8cm]{images/phase3_bypass}
\caption{Complete Environment with Monitors and Scoreboard}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth,height=8cm]{images/phase3_idcode}
\caption{Complete Environment with Monitors and Scoreboard}
\end{figure}


\subsubsection{Testing Conclusion for Phase III}

By this addition we have a complete testbench where the user does not have to physically check the waveforms for verification. The functions for comparison return the result on the console. The comparison starts when the \textit{startValidation} flag is raised.


\FloatBarrier
\subsection{Phase IV: Adding Boundary Scan registers}
Boundary Scan Registers are connected to every input or output pin. These control the data traveling into and out of the pins. For testing the EXTEST, INTEST and the SAMPLE/PRELOAD, these BSRs are imperative. During normal operation, the data is bypassed from the BSR. During the SHIFT DR state, the all the BSRs are connected serially between the TDO and the TDI.

\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase4Environment}
\caption{Complete Environment }
\end{figure}

\subsubsection{Testing Results for Phase IV}
\paragraph{SAMPLE/PRELOAD Instruction test}\mbox{}\\
\underline{Steps in which the SAMPLE/PRELOAD Instruction is executed:}
\begin{itemize}[noitemsep]
\item Move through the TAP controller states and reach the SHIFT IR state.
\item Shift-in the SAMPLE/PRELOAD instruction(4\'b0001) into the Instruction register. This means that the TAP controller remains at the SHIFT IR for 4 clock cycles. The value of TMS will be held to 0. TDI will be logic 1 for the 1st clock cycle and logic 0 for the next three clock cycles. This will inform the TAP controller that the SAMPLE/PRELOAD instruction is to be executed.
\item Move out of the Instruction Register state and navigate through the TAP controller states to reach the SHIFT DR state.
\item The Boundary scan cells are connected between the TDI and the TDO. The boundary scan cells are therefore filled-in(Preloaded) with the data stream from the TDI. At each clock cycle, the bits are shifted through. 
\item By accessing the data received on the TDO we read(sample) the data that was on the pins.
\end{itemize}

\paragraph{EXTEST Instruction test}\mbox{}\\
\underline{Steps in which the EXTEST Instruction is executed:}
\begin{itemize}[noitemsep]
\item Move through the TAP controller states and reach the SHIFT IR state.
\item Shift-in the EXTEST instruction(4\'b0000) into the Instruction register. This means that the TAP controller remains at the SHIFT IR for 4 clock cycles. The value of TMS will be held to 0. TDI will be logic 0 for the 4 clock cycles of TCK. This will inform the TAP controller that the EXTEST instruction is to be executed.
\item Move out of the Instruction Register state and navigate through the TAP controller states to reach the SHIFT DR state.
\item The Boundary scan cells are connected between the TDI and the TDO. The boundary scan cells are therefore filled-in(Preloaded) with the data stream from the TDI. At each clock cycle, the bits are shifted through. 
\item By reading the data received on the TDO we read(sampled) the data that was on the pins.
\item Move out of the Shift DR state and navigate through the TAP states and reach the SHIFT DR again.
\item Shift out the Boundary Scan register data via TDO. The result verifies the working of the internal circuitry also.
\end{itemize}
\begin{figure}[ht]
\centering
\includegraphics[width=12cm,height=8cm]{images/phase4_intest}
\caption{EXTEST Console Output}
\end{figure}

\paragraph{INTEST Instruction test}\mbox{}\\
\underline{Steps in which the INTEST Instruction is executed:}
\begin{itemize}[noitemsep]
\item Move through the TAP controller states and reach the SHIFT IR state.
\item Shift-in the INTEST instruction(4\'b1001) into the Instruction register. This means that the TAP controller remains at the SHIFT IR for 4 clock cycles. The value of TMS will be held to 0. TDI will be logic 1 for the 1st clock cycle, logic 0 for the next two clock cycles and logic 1 for the 4th clock cycle. This will inform the TAP controller that the INTEST instruction is to be executed.
\item Move out of the Instruction Register state and navigate through the TAP controller states to reach the SHIFT DR state.
\item The Boundary scan cells are connected between the TDI and the TDO. The boundary scan cells are therefore filled-in(Preloaded) with the data stream from the TDI. At each clock cycle, the bits are shifted through. 
\item By reading the data received on the TDO we read(sampled) the data that was on the pins.
\item Reach the UpdateDR state. In this state, the BSR passes the data stored in the BSR to the internal circuitry.
\end{itemize}

\FloatBarrier
\subsubsection{Testing Conclusion for Phase IV}
\ \\
The working of the boundary scan registers is tested. The BSR is successful in both parallel loading and serial transmission of the data. The Sample/Preload, Extest and the Intest operations, test all the conditions of operation of the BSRs.




\begin{sidewaysfigure}[ht]
\centering
\includegraphics[width=\textwidth, height=13cm]{images/phase4_intest_wave}
\caption{EXTEST testing}
\label{fig:LandscapeFigure}
\end{sidewaysfigure}
%===============================================================================================================
\newpage
\pagebreak
\FloatBarrier

\section{Conclusion}

We have now implemented a Device under test with JTAG capabilities. This can now be further extended to any DUT that is designed by replacing the \textit{full\_adder.v} file with any file that has the DUT to be tested. Only \textit{top\_module.v} needs to be modified for the instantiation of the modules. \textit{config.svh} file has been added. The user can change the configuration of the test by changing the values in the configuration file. This helps us isolate the DUT from the JTAG-interface. This makes the VC generic and can be easily replaced with any other DUT. The UVM environment would remain the same and we could test the complete functionality of the JTAG instructions.

The tests have been carried out to see the responses of the DUT to the BYPASS, IDCODE, SAMPLE/PRELOAD, INTEST and EXTEST instructions. The UVM environment compares the received and the expected values and gives an output on the console of the IDE. The user does not have to use the waveforms to manually verify the integrity of the signals. This reduces the time and effort that goes into testing of modules.

Provision has also been made to intentionally introduce errors into the testing modes. This gives us an idea of how the response would be when there is something wrong with the DUT. Also, this functionality helps cross verify our verification environment.
%
\newpage
\bibliographystyle{latex8}
\begin{thebibliography}{i}
\bibitem[1]{colin} {\em The Test Access Port and Boundary-Scan Architecture}, Colin M Maunder, et al., IEEE Computer Society Press, Los Alamitos

\bibitem[2]{1149} {\em IEEE Std 1149.1-1993}, IEEE Standard Test Access Port, and Boundary-Scan Architecture, IEEE, Inc., New York

\bibitem[3]{parker} {\em The Boundary-Scan Handbook}, Kenneth P. Parker, Kluwer Academic Publishers, Norwell

\bibitem[4]{xjtag} {\em High-Level Guide to JTAG},
\url{https://www.xjtag.com/about-jtag/jtag-high-level-guide/}

\bibitem[5]{microsemi} {\em IEEE Standard 1149.1},
\url{https://www.microsemi.com/document-portal/doc_view/130050-ac160-ieee-standard-1149-1-jtag-in-the-sx-rtsx-sx-a-ex-rt54sx-s-families-app-note}

\bibitem[6]{xilinx} {\em JTAG - General Description of the TAP Controller states},
\url{https://www.xilinx.com/support/answers/3203.html}

\bibitem[7]{IEEE} {\em IEEE Standard Test Access Port and Boundary Scan Architecture}, IEEE-SA Standards Board, 14 June 2001

\bibitem[8]{doulos} {\em Coverage driven Verification Methodology},
\url{https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/}

\bibitem[9]{doulos1} {\em UVM Verification Primer}, John Aynsley
\url{https://www.doulos.com/knowhow/sysverilog/uvm/tutorial_0/}

\bibitem[10]{accellera1} {\em Accellera's UVM User's Guide 1.1}

\bibitem[11]{accellera2} {\em Accellera's UVM 1.1 Class Reference}

\bibitem[12]{verificationAcademy} {\em Verification Academy's UVM Cookbook}

\bibitem[13]{spear} {\em SystemVerilog for Verification: A Guide to Learning the TestBench Language Features}, Chris Spear

\bibitem[14]{goss} {\em Comprehensive Functional Verification: The Complete Industry Cycle}, John Goss

\bibitem[15]{colorlesscube} {\em UVM guide for Beginners}
\url{https://www.colorlesscube.com/uvm-guide-for-beginners/}

\bibitem[16]{edaplayground} {\em EDA Playground}
\url{https://www.edaplayground.com}

\bibitem[17]{corelis} {\em corelis.com}
\url{http://www.corelis.com/education/Boundary-Scan_Tutorial.htm}

\bibitem[18]{xjtag2}{\em A technical overview of JTAG}
\url{https://www.xjtag.com/about-jtag/jtag-a-technical-overview/}

\bibitem[19]{fpga4fun}{\em How JTAG works}
\url{http://www.fpga4fun.com/JTAG2.html}

\bibitem[20]{TAPController}{\em JTAG - General description of the TAP Controller states}
\url{http://www.cnblogs.com/shangdawei/p/4753689.html}

\bibitem[21]{Osseiran} {\em Analog and Mixed-Signal Boundary-Scan: A Guide to the IEEE 1149.4 Test Standard}, Adam Osseiran

\bibitem[22]{UVMWiki}{\em Universal Verification Methodology}
\url{https://en.wikipedia.org/wiki/Universal_Verification_Methodology}

\end{thebibliography} 
%
%
% 
 
\end{document}